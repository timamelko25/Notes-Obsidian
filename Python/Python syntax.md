Переменные
переменная ссылка на объект в памяти
базовые типы bool, int, float, complex (мнимая часть указыавется j) и str (указывается в "..." '...' или многострочный в '''......''')
двоичная система 0b
восмиричная система 0o
шестандцатеричная система 0x
\\n переход на новую строку \\t табуляция 4 отступа

для вставки в строку данных функция f + заключение переменной в {...}
name = "Tom"
user = f"Hi {name}"

Python язык с динамической типизацией - переменная несильно привязана к одному типу данных 
функция type() показывает текущий тип данных у переменной
функция id() показывает уникальный идентификатор объекта

1. Строгая типизация (Strong Typing): В языках со строгой типизацией объекты имеют строго определенные типы, и операции между объектами разных типов требуют явного преобразования типов. Это означает, что недопустимы неявные автоматические преобразования типов.

Пример (Python - строгая типизация):  
x = 5  
y = "hello"  
result = x + y  # Ошибка, так как сложение int и str запрещено без явного преобразования

2. Нестрогая типизация (Weak Typing): В языках с нестрогой типизацией объекты могут автоматически преобразовываться из одного типа в другой в определенных ситуациях. Это может привести к неожиданным результатам и ошибкам, связанным с неявным преобразованием типов.

Пример (PHP - нестрогая типизация):  
$x = 5;  
$y = "hello";  
result=result=x + y; //y; //y автоматически будет преобразован в int, и результат будет 5

3. Статическая типизация (Static Typing): В языках со статической типизацией типы переменных и объектов определены на этапе компиляции или объявления, и они не могут изменяться в процессе выполнения программы. Это позволяет обнаруживать многие ошибки на ранних стадиях разработки.

4. Динамическая типизация (Dynamic Typing): В языках с динамической типизацией типы переменных определяются во время выполнения программы. Переменные могут менять свой тип в процессе выполнения. Это предоставляет гибкость, но также может привести к сложностям при обнаружении ошибок.

Разница между строгой и нестрогой типизацией заключается в том, насколько явно требуется указание типов для выполнения операций и насколько автоматически происходят преобразования типов. А разница между статической и динамической типизацией состоит в том, на каком этапе - во время компиляции или выполнения - определяются и проверяются типы переменных и объектов.

приоритеты операторов
or 1
and 2
not 3

![[Pasted image 20240923185658.png]]

...+ - конкатенация соединение строк
...* - дублирование размножение строкового формата 
str() - преобразование аргумента в строковое представление
len() - вычислене длины строки
in - проверка вхождения в строку
ord() - определение кода символа

строка - упорядоченный набор символов, нумерация начианется с 0
срезы строк str[index] str[start:stop:step] 
список упорядоченная коллекция данных
list = [1,2,3,4,5]
![[Pasted image 20240923185557.png]]

вложенные списки - n-мерные массивы
условыный оператор if
конарукция if else
тернарный оператор <значение1> if <условие> else <значение2>

циклы итераторы и генераторы 
while():
	...
for _ in range(start, end ,step):
	...
for <переменная> in <итерируемый объект>
break - досрочное завершение цикла
continue - пропуск одной итерации цикла 

Генераторы списков (List comprehension) - a = [<способ формиирования значения> for <переменная> in <итерируемый объект>]

Словари (dict)
словарь - упорядоченная коллекция
конструкция вида d = {"key1": "value1","key2":"value2",... }
![[Pasted image 20240928000005.png]]

Кортеж (tuple)
Кортеж - упорядоченная но неизменяемая коллекция произвольных данных

Методы кортежей
tuple.count - возвращает число найденных элементов с указанным значением
tuple.index(значение[, start[,stop]]) - возвращает индекс первого найденного элемента с указанным значением (start and stop необязательные параметры, индексы начала и конца поиска)

Множества (set)

Множество - неупорядоченная коллекция уникальных элементов, изменяемый тип данных.

**Можно** использовать в множествах:
	- числа
	- булевы значения
	- строки
	- кортежи
**Нельзя** использовать в множествах:
	- списки
	- словари
	- другие множества

Методы множества
![[Pasted image 20241103162406.png]]
![[Pasted image 20241103162419.png]]

Генератор множества  = [<способ формиирования значения> for <переменная> in <итерируемый объект>]

Функции
Объявление функции = def название_функции(параметры_функции(фактические параметры), именованный_аргумент = True((формальные параметры))

def name(age, surmane = "Max")

Вызов функции = название_функции(аргументы_функции)

Функции с произвольным числом параметров

def название_функции(\*args, \*\*kwargs)
	тело_функции
\* у функции - оператор упаковки аргументов. \*args представляет собой список фактических параметров (коллекция args представляет собой кортеж)
\* у функции - оператор распаковки аргументов. \*\*kwargs представляет собой список формальных параметров для передачи именованных аргументов (коллекция kwargs представляет собой словарь)

Лямбда (анонимные) функции
Lamda может быть записана как переменная в любой конструкции
lamda param_1, param_2, ... : команда
s = lamda a, b: a + b
s(1,2)

Замыкание функций
Замыкание (closure) или фабричная функция это функция определяемая и возвращаемая другой функцией, при этом замыкание получает доступ к значениям и объектам в области видимости "родительской" (или объемлющей) функции независимо от того из какой области видимости происходит вызов замыкания. Важной особенностью замыканий является тот факт, что они имеют доступ к самим объектам из области видимости родительской функции, а не к их копиям или состояниям существующим на момент определения замыкания.

Декораторы функций
декоратор - это функция, которая принимает ссылку на другую функцию и расширяет ее функциональность за счет вложенной функции
Для применения декорирования

@название_декорирования
def название_функции(параметры_функции):
	тело_функции
Функция декорирована

Работы с файлами
open(file [, mode = 'r', encoding = None, ...])
![[Pasted image 20241103175110.png]]
![[Pasted image 20241103175147.png]]

Функция map
Встроенная в Python функция `map()` используется для применения функции к каждому элементу итерируемого объекта (например, [списка](https://www.digitalocean.com/community/tutorials/understanding-lists-in-python-3) или [словаря](https://www.digitalocean.com/community/tutorials/understanding-dictionaries-in-python-3)) и возврата нового итератора для получения результатов. Функция `map()` возвращает объект map (итератор), который мы можем использовать в других частях нашей программы. Также мы можем передать объект map в функцию `list()` или другой тип последовательности для создания итерируемого объекта.

Функция filter
Функция `filter()` в Python применяет другую функцию к заданному итерируемому объекту (список, строка, словарь и т.дю), проверяя, нужно ли сохранить конкретный элемент или нет.

Функция `filter()` принимает два параметра - имя функции, содержащей условия для фильтрации входных значений, и итерируемый объект, к которому нужно применить функцию. В итоговый объект фильтра попадают те значения из итерируемого объекта, для которых вызов функции вернул **True**.

**Объект фильтра** — это итерируемый объект. Также можно конвертировать его в list, tuple или другие типы последовательностей с помощью соответствующих методов.

Функция zip
Функция `zip()` принимает на входе несколько итерируемых объектов (iterable) или итераторов (iterators) и поэлементно группирует в кортежи. Функция останавливается, когда заканчиваются элементы в одном из источников. Относится к неперезапускаемым генераторам.

map создаёт новый массив, меняя каждый элемент массива индивидуально. filter создаёт новый массив убирая элементы, которые не соответствуют условиямas
