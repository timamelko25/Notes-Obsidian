## Конкурентность, параллелизм

Конкурентность - выполнение двух задачи одновременно

Параллелизм - выполнение двух задачи в одно и тоже время

Конкурентность возможна когда несколько задач может работать независимо друг от друга. Возможно реализовать с помощью вытесняющей многозадачности

Параллелизм подразумевают конкурентность, но обратно не всегда.

Вытесняющая многозадачность - переключение задачи процессором с помощью квантования времени

Кооперативная многозадачность - явное определение переключения задачи в программе

в asyncio кооперативная многозадачность
Преимущества:
1. Экономия ресурсов. Когда ОС переключает задачу - контекстное вытеснение, требуется сохранить всю текущую информацию для работающего процесса чтобы потом его возобновить.
2. Гранулярность. Явное переключение задач дает выигрыш в эффективности

Процесс - работающее приложение, которому выделена область памяти, недоступная другим приложениям. При использовании квантования времени ОС автоматически вытесняет работающие процессы по истечении времени и передает процессор для выполнения другому процессу.

Поток - базовая единица, которой ОС выделяет время. Поток может выполнять любую часть кода процессора, включая те части, которые в настоящее время выполняются другим потоком. 
Поток использует память создавшего их процесса, также потоки ассоциированы с процессом, создавшим их. С каждым процессом ассоциирован минимум 1 поток, называемый главным. Процесс может создавать доп. потоки: рабочие, фоновые. Эти потоки конкурентно выполняют работу с главным потоком.

Пример процесса с главным потоком
```python
import os
import threading

print(f'Исполняется Python-процесс с идентификатором: {os.getpid()}')

total_threads = threading.active_count()
thread_name = threading.current_thread().name

print(f'В данный момент Python исполняет {total_threads} поток(ов)')
print(f'Имя текущего потока {thread_name}')
```

Пример многопоточности
```python
import threading

def hello_from_thread():
	print(f'Привет от потока {threading.current_thread()}!')
	
hello_thread = threading.Thread(target=hello_from_thread)
hello_thread.start()

total_threads = threading.active_count()
thread_name = threading.current_thread().name

print(f'В данный момент Python выполняет {total_threads} поток(ов)')
print(f'Имя текущего потока {thread_name}')
hello_thread.join()
```

Конкурентность можно добиться или многопоточностью или многопроцессорностью

Пример многопроцесорности
```python 
import multiprocessing
import os
def hello_from_process():
	print(f'Привет от дочернего процесса {os.getpid()}!')
	
if __name__ == '__main__':
	hello_process = multiprocessing.Process(target=hello_from_process)
	hello_process.start()
	print(f'Привет от родительского процесса {os.getpid()}')
	hello_process.join()
```
Многороцессорность предпочтительная для счетных задач. 

### Глобальная блокировка интерпретатора
global interpreter lock - GIL. Коротко GIL не дает процессу исполнять более одной команды байт-кода в каждый момент времени.

CPython - эталонная реализация Python, т. е. стандартная реализация языка которая используется как эталон правильного поведения. (есть также Jpython работающая под управлением виртуальной машины Java, IronPython для  .NET Framework)

В CPython память управляется с помощью подсчета ссылок. Для каждого объекта в памяти подсчитывается сколько объектов в данный момент использует его. Ссылки прибавляются или удаляются, если на объект никто не ссылается то он удаляется из памяти.
Конфликт потоков возникает из-за интерпретатор CPython не является потокобезопасным. Это значит что если два или более потоков модифицирует разделяемую переменную, то ее конечное состояние может оказаться неожиданным, поскольку зависит от порядка доступа к переменной со стороны потоков. Это ситуация называется состоянием гонки. Состояние гонки возникает при обращении 2 потоков к одному объекту.

 GIL освобождается на время выполнения операций ввода-вывода. 
 GIL в случае ввода-вывода низкоуровневые системные вызовы работают за пределами среды выполнения Python. На уровне ОС операции ввода-вывода выполняются конкурентно но не параллельно.

Рассмотрим конкурентность в рамках одного потока
Сокет - низкоуровневая абстракция отправки и получения данных по сети, обмен данных между клиентом и сервером. Поддерживает 2 основные операции: отправка и получение байтов. 
По умолчанию сокеты блокирующие: на все время ожидания ответа от сервера приложение приостанавливается или блокируется. На уровне ОС сокеты могут работать в неблокирующем режиме. 
При получении байтов ОС отправляет уведомление с помощью событий:
- kqueue - FreeBSD MacOS
- epoll Linux
- IOCP Windows

### Цикл событий 

Цикл событий - паттерн проектирования для отправки асинхронных запросов.
Создается очередью в которой хранится список событий или сообщений, а затем вход в бесконечный цикл, где обрабатываются сообщения по мере их поступления.

asyncio обрабатывает не сообщения а задачи. Задача - обертка вокруг сопрограммы.

### Сопрограммы
Сопрограмма - функция которая может приостанавливаться для выполнения более затратной задачи. 
async - определение сопрограммы 
await - приостановка на время 

```python 
async def test() -> None
	print('async')

result = asyncio.run(test())
```

Сопрограммы не выполняются если хи вызвать напрямую. Вместо этого возвращается объект сопрограммы, который будет выполнен позже.
Для выполнения сопрограммы необходимо передать ее циклу событий, один из вариантов asyncio.run.

Ключевое слово await для приостановки выполнения. Помещается перед вызовом сопрограммы.

```python
imort asynio

async def add_one(number):
	return number + 1

async def main():
	one_plus_one = await add_one(1)
	two_plus_one = await add_one(1)
	print(one_plus_one)
	print(two_plus_one)

async.run(main())
```
![[Pasted image 20241115002825.png]]Встретив выражение await, интерпретатор приостанавливает родительскую
сопрограмму и выполняет сопрограмму в выражении await. По ее завершении
родительская сопрограмма приостанавливается и возвращенное ей значение
присваивается переменной

ключевая команда sleep
asyncio.sleep заставляет сопрограмму заснуть на заданное число секунд. asyncio.sleep является сопрограммой, вызывается с помощью await.
Вызвав напрямую получим объект сопрограммы.

### Конкурентное выполнение с помощью задач
Задача - обертка вокруг сопрограммы которая планирует выполнение последней в цикле событий как можно раньше.  И планирование и выполнение происходят в неблокирующем режиме, т. е. создав задачу можно приступить сразу к выполнению другого кода, пока эта задача работает в фоне.
Для создания служит функция asyncio.create_task(). ей передается подлежащая выполнению сопрограмма, в ответ немедленно возвращает объект задачи.

```python
import asyncio
from util import delay

async def main():
	sleep_for_three = asyncio.create_task(delay(3))
	sleep_again = asyncio.create_task(delay(3))
	sleep_once_more = asyncio.create_task(delay(3))
	await sleep_for_three
	await sleep_again
	await sleep_once_more
	
asyncio.run(main())
```

![[Pasted image 20241115005033.png]]

