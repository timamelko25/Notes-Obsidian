Каждый процессоор может воспринимать свой набор команд

Самые распространенные архитекрутры x86(компьюетры, сервера), ARM (мобильные устройства, планешеты), AVR (микроконтрелеры встроенных систем (машины, телевизоры)).Каждая из этих архитектур поддерживает свой набор команд.

Разрядность процессора - велечина, которая определяет размер машинного слова. Машинное слово - максиамльное количество бит, которым может оперировать процессор за раз. Обменить их с регистром, с оперативной памятью

|#|Модель/технология|Разрядность|Число (адрес ОЗУ)|
|---|---|---|---|
|1.|с 8086 по 80286|16 бит|от 0 до 65535|
|2.|с 80386 … (х86)|32 бита|от 0 до 4294967295|
|3.|AMD64 == EM64T (x86-64)|64 бита|от 0 до 2^64|

Для начала работы процессора ему нужно считать информацию из памяти и куда-то положить, чтобы с ней можно было работать. Для этого в процессоре есть 2 вида памяти: регистровая память и кеш память.

Регистиры - маленькие ячейки памяти, расположенные на процессоре. (самая быстрая).

Максимальная размер регистра = разрядность.

Регистр должен быть кратен ячейке оперативной памяти.

Все регистры можно условно разделить на:

1. регистры специального назначения

Назначаются для конкретного содержимого в них.

В сегментых регистрах хранятся адреса памяти SS CS DS

В регистрах для работы со стеком указывают на начало фрейма или верхушку стека BP SP

Флаговые регистры содержат разлчиные биты показывающие состояние результата предыдущей операции FLAGS

Указатель команд содержит адрес команды, которую нужно выпонить следующей IP

1. регистры общего назначения (переменные, параметры, результаты вычислений)

регистр AX - 16 бит. Состоит из AH - 8 бит, AL - 8 бит

Процессор 32 бита EAX - 32 бита. состоит из 16 свободных и AX.

Процессор 64 бита RAX - 64 бита. Состоит из 32 свободных и EAX

Получается матрешечный тип с поддержкой старых регистров.

Что если записать больше чем размерность регистра

Запишем в первый регистр 120 MOV AH, 120

Запишем во второй регистр 10 MOV AL, 10

И суммируем ADD AH, AL

В знаковый байт помещаются числа от -128 до 127. То есть 130 уже не запишится. В этом случае происходит Переполнение. Переполнение происхоит при суммировании 2-х больших положительных чисел или вычитание 2-х больших отрицательных числа. В этом случае страшие биты, которе не помещаются в регистр, отсекаются и результатом будет являться число, которое осталось после этого отсечения.

Получается 120 + 7 = 127 еще прибавить 3 нужно

127+1 = -128 Оказывается в противоположном конце

-128 + 3 = -126

Конечное число будет -126 и обратный знак операции показывает, что произошло переполнение.

Язык Ассемеблер - низкоуровневый язык программирования

Ассемблер - программа-трансялтор этого языка в машинный код, где все символические команды будут представлены в двоичном коде, которые соответсвуют командам в архитектуре процессора.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc93acf9-0c65-448b-8aee-172ff6347445/f8d966e0-f1f0-4577-a3c3-b0f5e58e2f92/Untitled.png)

Процессор при включении начинает воспроизводить команды по фиксированном адресу. По этму адресу располагается биос (базовая операционая система ввода-вывода), где считывается первое дисковое устройство, взять оттуда первый сектор, взять его в память и передать на него управление. То есть указать процессору на то где теперь он начнет выполнять команды по адресу этой загруженной комнады. Этой программой является ОС которая в дальнейшей переводит процессор в защищенный режим, реализуется многозадачность, выставляются различные ограничения…

Далее запускается программа, ОС выделяет для нее место, загружает ее в оперативную память после передает управление. Это означает сказать процессору с какого места из памяти ему нужно выполнить следующую команду. Здесь используется указатель команд (IP - instruction pointer). После того как процессор получил данные из памяти по этмоу адресу, который был IP, он обновялет значение в этом регистре, чтобы он указывал на следующую инструкцию в памяти. То есть определяет размер следующей инструкции и прибавляет ее к текущему значению IP. Таким образом указатель сдвигается ровно на 1 инструкцию вперед

Адреса по которым процессор обращается к памяти определяются программами в ходе их выполнения. Механизм трансляции адресов позволяет защитить адреса.

Режимы работа процессора

|#|Режим работы|Разрядность|Число (адрес ОЗУ)|
|---|---|---|---|
|1.|Реальных адресов|16 бит|от 0 до 65535|
|2.|Защищенный|32 бита|от 0 до 4294967295|
|3.|64 разрядный|64 бита|от 0 до 2^64|

Режим реальных адресов: процессор переходит в него сразу после включения компьютера. Адрес сформированный программой является реальным и не требуют дополнительных преобразований

Режим работы защищеный: можно перейти только из режима реальный адресов. Нужен для обеспчения защиты данных между операционной системой и прикладных программ и данных программ друг от друга благодаря разделению этих программ на разные уровни привилегий. После того ка ОС получает управление она переводит процессор в защищенный режим выставляя специальный флаг регистра, устанавливает разрешения и условия для других программ, определяет таблицы дискриптеров и прерываний. Таким образом прикладные програмы ограничены ОС. Процессор следит за соблюдением этих правил не позволяя переопределять условия ОС

В случае нарушения генерируются исключения, управление передается ОС, чтобы она приняла меры.

Режим 64 разрядный: можно перейти только из защищенного режима и так же соблюдается защита програм друг от друга.

Официальная классификация AMD и INTEL

|#|Режим работы|AMD|INTEL|
|---|---|---|---|
|1.|Режим реальных адресов + защищенный|legacy mode|IA-32|
|2.|64 разрядный режим + режим совместимости(поддержка 64 и 32 разрядного кода)|long mode|IA-32e|

Уровни привилегий - доступ к использованию ресурсов процессора.

В режиме реальных адресов нет уровней привелегий так как может выполняться только 1 программа.

Существует 4 уровня привелегий:

0 (привелегированный) - полный доступ к процессору. на нем работает операционная система.

1 (менее привелегированный) - запреты установленный на 0 уровне, будут действовать на 1 уровень. Используется редко

2 - по аналогии с первым

3 (пользовательский) - самый низкий приоритет и подчиняется всем нижестоящим уровням. На нем работают все прикладные программы и у них нет доступа к данным другого уровня

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc93acf9-0c65-448b-8aee-172ff6347445/c99aa888-fd2e-4178-b1c8-38a7ebea3de4/Untitled.png)

Устройство адресации

Вся оперативная память поделена на сегменты - отдельные участки памяти определенного размера, размер завистит от режима работы процессора.

Адрес конкретной ячейки памяти который выставляют программы представляются в специальном формате.

адрес начального сегмента (16 бит) / смещение в сегмента (16 бит) = логический адрес

В режиме реальный адресов вся память делится на сегменты размером 64 кб. Адрес сегмента и смещение представляют собой 16 бит числа которые являются реальными адресами и смещениями сегмента в памяти.

Логический адрес преобразуется в физичесикй адрес (20 бит), который будет выстален на шину адреса.

адрес начала сегмента << 4 + смещение в сегменте = физический адрес. максимальный количество адресов которое можно адресовать 2^20 = 1 мб

В защищенном режиме вся память делится на сегменты 0-4 гб. ОС создает иллюзию что у программы есть все доступные адресные пространства в распоряжении. В этом режиме ОС создает механизм трансляции виртуальный адресов в физические. Программы как бы работают в виртуальном мире так же создавая адреса предполагая, что обращаются к рельным адресам. В ходе работы программы логичский адрес становится виртаульным. И теперь логический адрес формируется по-другому

логичесикй адрес = селектор (16 бит) / смещенеи в сегменте (32 бит)

селектор представляет собой индекс дескрипотра

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc93acf9-0c65-448b-8aee-172ff6347445/1466d338-560c-4878-bc3f-85cda1fee2a3/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc93acf9-0c65-448b-8aee-172ff6347445/b0e67906-194a-4dc7-9961-40252ff32bbe/Untitled.png)

Страничная организация памяти (виртаульная память)

Все даресное пространство разбивается на страницы - непрерывные области памяти (размер зависит от режима работы процессора и режима трансляции адресов)

каждая страница описывается структурой которая объединяется в специальную таблицу страниц. Каждая таблица страниц описывается отдельной структурой и они объединяются в каталог страниц

При каждом обращении к памяти адрес делитс яна 3 части:

1. индекс в каталоге страниц (из которого извлекается физический адрес таблицы страниц)
2. индекс в таблице страниц (из которого извлекается физический адрес страницы)
3. смещение в странице

Далее при помощи механизма трансляции адресов происходит преобразование адреса в 32 бит физический адрес. Максимально можно адресовать 2^32 = 4 мб памяти.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc93acf9-0c65-448b-8aee-172ff6347445/2af9e1e1-56f4-48cd-9b60-58e15f5b219f/Untitled.png)

64 разрядный режим - расширение 32 битной архитектуры под 64 битную. Общая концепция та же. Полностью отключена сегментация. Адресовать в виртуальной макс. 2^48, в реальной 2^52. Ограничения обусловлены работой процессора и ОС.

Работа с внешними устройствами

Внешнее устройство (клавиатура), чтобы рабоать без задержок, устройство через контроллер прерываний дает процессору сигнал о перрывании - сигнал ппроцессору о том, чтобы он прервал выполнение текущей программы и передал управление специальной функции обработки прерывания.

Функции обработчики представляют собой обычные прерывания котрые постоянно находятся в памяти и могут вызываться в любое время.

Получив сигнал процессор генерирует прерывание передавая управление обработчику прерывания. текущая прогрмма прерывается, сохраняется состояние (регистры, адрес следующей инструкции…). После завершения обработчик передает управление прерванной программе, восстанавливается последнее сохраненное состояние и программа продолжает работу с того места с которого была прервана.

Прерывания находится в таблице дескрипторов прерываний. Уровень привелегий у этой таблицы который определяет уровень привелегий программы которая может воспользоваться этим прерыванием.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc93acf9-0c65-448b-8aee-172ff6347445/9063f8e7-8305-4b93-9284-e7a813cee8d6/Untitled.png)

Виды прерываний:

1. программный - генерирует сам программист. есть в MS-DOS в режиме реальных адресов. Операнд означает номер дескриптора прерываний в таблице дескриптора.
2. апаратный - генерируется контролером прерываний выступающим связующим звеном между процессор и устройством. Прерывания обрабатываются согалсно приоритетам, что позволяет избегать коллизий, которые появляются если поступает сигнал от сразу нескольких источников.
3. исключения - формирует процессор при попытке программы нарушить ограничения защиты или при возникновении ошибок в ходе ее выполнения.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc93acf9-0c65-448b-8aee-172ff6347445/3ae511e2-ba96-4268-83dc-a182d10fb703/Untitled.png)

Прерывания позволяют переключать программы на другие. на этом основана многозадачность - одноврменная иллюзорная работа всех программ на компьютере. Механизм работает программно.

Прогрмма - большой единый набор инструкций. Все программы разбиваются на процессы. Процессы на потоки/задачи. И уже задача самостоятельная последовательность команд, которая выполянется в своем окружении. Потоки выполняются неодновременно, они очень быстро преключатся, сохраняя свои состоянии и потом возобновляя их.

Ядро - огромный центр преобразований данных. Состоят из транзисторов, получая на вход 0 или 1.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc93acf9-0c65-448b-8aee-172ff6347445/637a1dcb-c374-4d36-9e3a-7eeda8214959/Untitled.png)

Состоит из устройство управления и арифметико-логическое устройство(УУ и АЛУ).

Используются МОП транзисторы

Кеш процессора

Суть кеширования - сокращение задержек доступа. Сокращение времени обращения от оперативной памяти к процессору.

Кеш процессора можно рассматривать как оперативную память. Используется та же двоичная адресация, те же данные, инструкции.

Кеш состоит из контроллера и кеш памяти. Чтение из оперативной памяти происходит передачей нескольких машинных слов. Процессор не может напрямую принять все эти данные в регистр поэтому они записываются в кэше. Когда процессор формирует запрос на получение данных он перехватывается контроллером который определяет имеются ли копия требуемых данных в кэше и если имеются минуя оперативную память переходит в процессор если их нет запрос передается в оперативную память. Среднее время получение данных сокращается.

Измененные данные записываются обратно в кэш, где потом они выгружаются в оперативную память на то же место. Такая схема называется write back. Работает быстрее чем write trough (сохранение данных сразу в кэш и оперативную память. хотя при перебое питании данные не будут утеряны).

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc93acf9-0c65-448b-8aee-172ff6347445/d922ecd3-0f57-4a35-b32a-7f0761eb0ce5/Untitled.png)

1 вопрос. Как вернуть данные обратно в оперативную память по нужному нам адресу

Адрес нужно хранить. Данные адреса хранятся не в виде отдельных байтов а в виде целых блоков данных, идущих в оперативной памяти подряд. Блок данных называется кэш строка/кэш линия. Размер строки в современных компьютерах 64 байта. В каждой строке вместо адреса для каждого байта можно хранить всего лишь 1 адрес из оперативной памяти который соответствует адресу первого сохраненного байта данных.

Какого размера кэш память. Размер кэша = 2 ^ (…). Размер так же должен быть кратен 4, чтобы эффективно расходовать место.

Размер кэша носит название полезный размер кэша. Он указывается в документации. Размер без указания служебных данных

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc93acf9-0c65-448b-8aee-172ff6347445/337ff522-2065-4c2b-844f-f1427879e5d1/Untitled.png)

2 вопрос. В какую конкретно строку кэш памяти попадет определенный блок памяти из оперативной памяти.

Возьмем кэш размером 256 байт. Размер каждой строки 64 байта. Получится 4 строки. Возьмем оперативную память на 1 кб и поделим на 4 сегмента. В каждом сегменте разделим данные по 64 байта.

Кэш прямого отображения

Каждая строка оперативной памяти соответствует только 1 четко определенной кэш памяти. Каждой строке кэш памяти будет соответствовать несколько строк из оперативной памяти. Разделив по модулю номер каждой строки из оперативной памяти на количество строк кэша мы получим что в первую строку кэш памяти попадут 0,4,8,12 строки из оперативной памяти.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc93acf9-0c65-448b-8aee-172ff6347445/892c5dff-ba7c-49d6-b8b3-81c82c538f1d/Untitled.png)

32-х битный адрес в кэш строке будет подразделяться на 3 основные части.

Смещение до слова в строке, индекс строки и тег - старшая часть адреса байта/номер сегмента в оперативной памяти/число которое будет сравниваться с адресом 1-го байта который хранится в кэш строке.

Размер каждой части будет зависеть от размера кэша

Смещение зависит от размера кэш строки. Для обращения к любому байту внутри кэш строки требуется 6 бит для 64 байта смещения. Так как процессор высчитывает данные по словам 6 битное смещение делится еще на 4 бита - поиск слова, 2 бита - поиск бита

Индекс строки зависит от количества строк в кэше. То есть для 4 строк потребуется 2 бита. Возьмем слово которое начинается с адреса 64. Мы знаем что оно попадет в 1 строку на первое место. И чтобы не перебирать все кэш строки для поиска нужной из средней части адреса извлекается адрес кэш строки. Проблема что в этой кэш строке могут находиться и данные из других строк.

Чтобы понять в строке именно те данные которые мы ищем поле тега сравнивается с адресом который записывается в каждой кэш строке, такой адрес тоже называется тег. Так как размер данных равняется размеру кэш строки и отсчет начинается с 0 то этот адрес в кэш строке будет кратен размеру кэш строки и размеру данных

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc93acf9-0c65-448b-8aee-172ff6347445/4392f978-4ec4-45fd-819b-9f6f9d7e22c5/Untitled.png)

Если представить каждый адрес представить в двоичном виде то последние 6 символов будет всегда 0.

![64 бита. для 32 будет кратно 5. 16 4](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc93acf9-0c65-448b-8aee-172ff6347445/3e81a166-8400-4e55-8131-dc5f4b305826/Untitled.png)

64 бита. для 32 будет кратно 5. 16 4

Поскольку эти биты всегда = 0 их можно не хранить. Получается что вместо 32 битного адреса мы можем хранить 26 бит. Поле тега равно 24 бит.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc93acf9-0c65-448b-8aee-172ff6347445/c86c998b-1c3e-40f0-b37f-0a2f071ea5af/Untitled.png)

Если из оставшихся 26 бит в адресе кэш строки мы оставим старшие 64 бита, то все адреса относящиеся к 0 сегменту будут равны 0. Все адреса относящие к 1 сегменту будут равны 1. При этом все адреса из одного сегмента будут находится в разных кэш строках.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc93acf9-0c65-448b-8aee-172ff6347445/1c624ccf-bde7-4faa-8f38-8771543a9ee4/Untitled.png)

В итоге число из поля тега в адресе сравнивается с оставшейся частью адреса которая записана в адресе кэш строки. И если все совпало то такая ситуация называется кэш попаданием.

Недостатком кэша прямого отображения в том что разные строки оперативной памяти претендуют занять одну и ту же строку в кэш памяти. Это порождает возможность частых коллизий. Если нам нужна 4 строка из оперативной памяти, а в кэше уже лежит 8 строка то мы идем в оперативную память. Это называется кэш промахом.

Для сокращения подобных ошибок нужно чтобы в кэш памяти помещалось несколько строк. Придумали еще один вид кэш памяти который называется Наборно-ассоциативный кэш.

Весь кэш делится на несколько сегментов называемые каналы. Каждый из которых является обычным кэшем прямого отображения. Сами сегменты полностью ассоциативны по отношению к оперативной памяти. Любая строка может быть размещена в любом сегменте кэша. Но внутри каждого сегмента ей будет соответствовать кэш строка. Количество каналов тоже должно быть кратно 2.

Возьмем 4 канальный кэш в каждом из которых будет по 4 строки. Определить какая строка из оперативной памяти в кэш строку можно как раньше, но теперь она может попасть в любой из 4 каналов. Адрес к данным в кэше остается таким же. Тегом строки с нужным индексом в каждом из 4 каналов (такой набор называется сетом) и одновременно сравнивается с тегом в адресе. То есть сколько будет каналов столько будет одновременно сравниваемых тегов. Это снижает вероятность коллизий и скорость работы кэша остается такой же.

Можно еще больше снизить коллизий используя полностью ассоциативный кэш.

То есть любая строка из оперативной памяти может попасть в любую строку кэша. Проблема в производительности возникает. Чтобы найти нужную строку необходимо перебрать все строки в поисках нужной. Это будет выгодно только если кэш имеет небольшой размер.

Так как кэш всегда полон то данные в него могут попасть только путем замещения другими данными. Процессор может обратиться к данным в кэше которых там не окажется. В таком случае они будут взяты из оперативной памяти. Замещение по требованию приведет к большому количеству кэш промахов. Чтобы уменьшить их количество кэш контроллер должен предсказывать какие данные потребуются процессору в следующий момент времени. Постоянно их подгружая и замещая их.

Чтобы определить какие данные являются ненужными используются различные алгоритмы. Например LRU (least recently used) - замещаются те данные, к которым дольше всего не было обращений, MFU (most frequently used) - замещаются последние используемые данные, LFU (least frequently used) - замещаются данные, которые использовались реже всех. Для алгоритмов требуется добавление в служебные данные счетчика возраста который обновляется после каждого обращения к строкам. Это касалось строк которые мы замещаем. Для определения какие строки нужны из оперативной памяти тоже используются алгоритмы.

Данные и инструкции хранятся в разных местах.

Кэш состоит из нескольких уровней. Его задача ускорить работу компьютера. Чем больше размер кэша тем дольше врменени нужно на обработку данных и тем самым ниже сокрость работы. ПОэтому используется несколько маленьких.

Обычно используется 3 уровня кэша:

1. L1 кэш первого уровня
2. L2
3. L3

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc93acf9-0c65-448b-8aee-172ff6347445/ee381e7e-031f-4c6b-b0f1-8025d2116116/Untitled.png)

Предположим что L1 делится на 8-канальный кэш данных и 4-канальный кэш инструкций. По 32 кб каждый. Каждый кэш принадлежит своему ядру. L3 распределяется на все ядра.

Как они работают все вместе. Возьмем L1 и L2. L2 строится по одной из двух архитектур по отношению к L1. Либо inclusive в которй L2 дублирует данные L1 либо exclusive в которой данные не дублируются.

Inclusive Строка из оперативной памяти загружается в L2 и если он заполнен, то заменяется невостребованная строка. Далее L2 передает данные в L1, если он заполнен, то тоже ищутся строки которые можно перезаписать. Так данные будут хранится в L1 и L2.

Exclusive Начинается так же и при нехватке места в L1 вместо перезаписи данных, он обменивается данными с L2.

В зависимости от используемых типов данных будет зависеть скорость обработки данных процессора. В 64 бит процессорах из кэша считвается 64 бита информации. Заполнив кэш 8,16,32,64 битными данными быстрее всего считваются 64 бита. При выборе 8,16,32 биты будут отброшены и на это тоже уйдет время. При этом чтение 8,16,32 бита будет произвдено за одинаковое количество врмени. Нельзя использовать все данные на 64 бита потому что память быстрее забьется и нужно чаще обращаться к оперативной памяти.

Разные програмым по-разному обрабатывают типы даынных и поэтому есть процесс расширения численного типа. Во время битовых, арифметических,сравнения… целые типы меньше 32 бит приводятся к 32 битам. Касатеся знаковых и беззнаковых типов, происходит в явном и неявном виде и зависит от языка

Программа может хранится в оперативной памяти в рахных местах и размер может быть больше самого кэша. и программу нельзя записать в кэш и полностью изолировать в оперативную память тоже не получится. При многоядерной или многопроцессорная системы, одни и те же данные могут использоваться одновременно разными кэшами. Поэтому может возникнуть ситуация когда из определенной ячейки памяти оперативной памяти копия который уже была изменена в кэше но не ыбла выгружена обратно обращается другой процессор. И еще если в каждом кэше будут модифицироваться одни и теже данные, то будет сложность слияния данных обратно в оперативную память. Нужна возможность сравнивать данные из оперативной памяти и данные из кэша. Согласованность данных там и там называется когерентность кеша. Для его реализации было введено несколько состояний. При котором только в одном кэше может изменяться ттолько одна конкретная кэш строка. Когерентность кэша может описывать разными протоколами которые могут отличаться от вида процессора.

Для примера возьмем 3 процессора и 3 абстракных кэша. Первый процессор отправляет запрос на получение данных из оперативной памяти. Изначально ей ставится состояние shared озночающее что в данной строке содержится свежые данные полностью совпадающие с оперативной памятью и оно же подразумевает что данная строка может присутствовать в разных кэшах. Это дает возможность читать данные сразу всем процессорам. И когда первому процессору необходимо внести изменения в первую строку, он должен сообщить всем, что копии этой строки перестают быть акутальными и их больше нельзя использовать. Далее идет состояние invalid и обращение к такой сторке означает кэш промах. Посое этого первй процесоор вносит изменения в строку и состояние меняется на Modified. То есть данные самые свежие. И если нужна будет перезапись данных то она произойдет без дополнительных действий. Что если третий процессор обратиться к modified данным - данные из оперативной памяти устаревшие и их брать нельзя, поэтому запрос данных прерывается. Modified строка скидывает изменения и третий снова обращается к этой строке и после получается состояние shared. Такой процесс соответсвует протоколу MSI. Проблема что лубая строка в состоянии shared является потенциально разделяемой и это приводит к тому что нам всегда нужно сообщать другим кэшам состояние даже если данные неразделяемые (данных нет в других кэшах). Большая часть данных в программах не нуждается в разделении и чтобы оптимизировать данное состояние есть exclusive. Когда строка загружается в кэш. Есть 2 варианта которые она получит. Если данные строки уже присутвуют в других кэшах она получит состояние shared. Если данные нигде не записани то она получит состояние exclusive. То есть единсвтенную копию во всех кэшах. Если потребуются изменения то мы сразу их делаем без оповещения других процессоров. Такой протокол MSIE.

Недостатки такого метода. Если в кэше лежит мидифицированная строка следовательно в оперативной памяти лежит старая копия и второй процессор обращается к этой строке мы должны обновлять данные в оперативной памяти после чего они будут получены другим процессором. Зачем это делать когда у процессора есть измененные данные и он может ответить на запрос чтения этой строки вместо оперативной памяти. Для этого мы вводим состояние owned. Когда все копии находятся в состоянии shared запросы чтение идут в оперативу когда состояние modified то запрос чтение меняет состояние на owned и сразу пересылает данные в запрашиваемый процессор в ктором строка получит состояние shared. Когда строка в состоянии owned она продолжит отвечать за запросы чтения остальным процессорам. Когда возникнет необходимость модифицировать ее все разделенные копии будут переведены в состояние invalid. Если будет имзенена строка shared, то owned станет invalid а shared станет modified. Проблема при чтении данных с разделяемыми строками мы постоянно обращаемся к оперативной памяти вместо того чтобы обращаться к другим кэшам. Это было решено в протоколе MESIF (f - forwarded) имено строка состоянием forwarded будет отвечать нга запрос строки дургими процессорами и чтобы избежать замещения строки состояния forwarded. Эта строка перехоидит состоянием forwarded а старая становится shared. Если все же строка состоянием forwarded будет замещена в таком случае запрос на получение будет отправлен в оперативную память. В этом протоколе снова возникает проблема сброса данных когда мы получаем строку чья копия уже есть в другом кэше в modifeid состоянии. Так же есть много других протоколов.