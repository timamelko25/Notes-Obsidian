
Docker - платформа, предназначенная для разработки, развертывания и запуска приложений в виртуальных контейнерах.

Виртуальная машина и контейнер

Виртуальная машина

Виртуальная машина (VM) - абстрактная вычислительная среда, которая создаётся программным способом на физическом оборудовании и имитирует компьютер или сервер с полноценной операционной системой и аппаратным обеспечением. Является эмуляцией реального компьютера, работают поверх физической машины с помощью HyperVisor

HyperVisor (гипервизор) - часть программного обеспечения, прошивки или оборудования на котором работают виртуальные машины. HyperV работает на физических компьютерах, называемых "хост-машиной". Хост-машина предоставляет виртуальным машинам ресурсы компьютера (ЦП, Оперативная память). Виртуальная машина работающая на хост-машине называется "гостевой машиной". Гостевая машина содержит в себе приложения, двоичные файлы, библиотеки, виртуализированный аппаратный стек, включая виртуализированные сетевые адаптеры , хранилище, ЦП - есть полноценная гостевая ОС.

Гостевая машина может работать на размещенном HyperV, так и на bare-metal HyperV.

HyperV

Размещенный гипервизор виртуализации работает на ОС хост-машины. У виртуальной машины нет прямого доступа к оборудования, поэтому она должна проходить через хост-ОС.

Преимущества размещенного гипервизора: базовое оборудование менее важно. ОС хоста отвечает за драйвера оборудования, а не за сам гипервизор и поэтому считается более "совместимой с оборудованием".
С другой стороны это дополнительный слой между оборудованием и гипервизором создает больше накладных расходов ресурсов

![[Pasted image 20250319150133.png]]

Bare-metal HyperV

Решение проблемы производительности: среда гипервизора ставится на оборудование хост-машины и работает с него. Работает напрямую с оборудованием, не нужна ОС хоста. Теперь первое что ставится в качестве ОС будет гипервизор. Такой гипервизор имеет собственные драйвера устройств и взаимодействуют с каждым компонентом напрямую для любых задач ввода-вывода, обработки или ОС. Это обеспечивает лучшую производительность, масштабируемость и стабильность, но совместимость с оборудованием ограничена, поскольку гипервизор может иметь только определенное количество встроенных драйверов.

!написать про гипер в [Архитектура Hyper-V: Глубокое погружение / Хабр](https://habr.com/ru/articles/98580/)

Контейнер

Контейнер - изолированное пространство, которое позволяет запускать приложения с их зависимостями отдельно от основной системы. Так же является запускаемым экземпляром класса

Преимущества:
- Автономный. Каждый контейнер имеет все необходимое для функционирования без зависимости от каких-либо предустановленных зависимостей на хост-машине
- Изолированный. Минимальное влияние на хост машину и другие контейнеры
- Независимый. 
- Портативный. 

Недостатки:
- Зависимость от ядра ОС, что может ограничивать использование технологий
- Сложная реализация оркестрации, необходимость использовать дополнительное ПО (Kubernetes)
- Безопасность. Проверка сторонних образов из общедоступных реестров 

Docker используется для создания и управления контейнерами, обеспечивая их изоляцию и быструю настройку.
Kubernetes занимает оркестрацией, помогая управлять множеством контейнеров, распределяя нагрузку и поддерживая высокую доступность сервисов.

`libcontainer` - docker использовал для взаимодействия с CGroups и Namespaces. Сейчас идет управление через `runc` куда включено `libconrainer`

Архитектура Docker разбита на 4 компонента: 
- Docker engine
- containerd
- containerd-shim
- runc

![[Pasted image 20250607220731.png]]

Этапы запуска контейнера 
1. Docker engine создает контейнер (их образа) и передает в containerd
2. containerd вызывает containerd-shim
3. containerd-shim используется для запуска runc
4. containerd-shim позволяет среде выполнения (в данном случае runc) завершиться после запуска контейнера

Таким образом можно запускать контейнеры без служб (deamon-less-containers). Их преимущества:
1. runc может завершиться после запуска контейнера и не нужны запущенные все процессы исполнения
2. containerd-shim - сохраняет открытыми файловые дескрипторы, такие как stdin, stdout, stderr даже когда Docker и/или containerd завершаются

![[Pasted image 20250607220719.png]]

В отличии от виртуальной машины, которая обеспечивает аппаратную виртуализацию, контейнер обеспечивает виртуализацию на уровне ОС, абстрагируя "пространство пользователя"
Имеют частное пространство для обработки, выполнение команды от root, частный сетевой интерфейс и IP-адрес, допускают пользовательские маршруты и правила iptable (контроль входящего и исходящего трафика, проброс портов), могут монтировать файловые системы..

Большое различие VM и контейнера: контейнер использует ядро хост-системы совместно с другими контейнерами.
![[Pasted image 20250319152346.png]]

Контейнер упаковывает только пользовательское пространство, а не ядро или виртуальное оборудование. Каждый контейнер получает собственное пользовательское пространство 

Что используется для контейнеризации
- Namespaces
	- PID - ограничение процесса от других
	- Networking - ограничение по сети
	- Mount - ограничение по файловой системе
	- User - ограничение по пользователям
- Control Groups (CGroups) - управление ресурсов у контейнера
	- Memory
	- CPU
	- BLOCK I/O
	- Networking
- Capabilities - ограничение прав доступа у процесса
- Copy-on-Write - работа с образами докера

Docker Engine
Движок Docker - клиент-серверное приложение
Слой на котором работает Docker. Это среда выполнения и инструментарий, который управляет контейнерами, образами, сборками...

Состоит из:
- Docker Daemon
- Клиент Docker взаимодействует с Docker Daemon для выполнения команд
- REST API для удаленного взаимодействия с Docker Daemon

Клиент Docker
Конечный инструмент для взаимодействия с пользователем. Может работать на хост-машине, но необязательно. Может работать на другой машине и обращаться с Docker Daemon, который работает на хост-машине. Применяется для управления отдельными контейнерами, из которых состоит приложение

Другой клиент Docker - Docker Compose, который позволяет работать с приложениями, состоящими из набора контейнеров. Для работы с множеством контейнеров использует YAML-файлы. Используется для одновременного управления несколькими контейнерами

![[Pasted image 20250324025113.png]]

Docker Daemon
Демон Docker - это сервер ожидающий команд отправленных от клиента к API Docker, например, сборка, запуск распространение контейнеров. Работает на хост-машине.

Клиент и демон Docker взаимодействуют с помощью REST API через сокеты UNIX или сетевой интерфейс.


Docker Registry - хранит образы Docker. Docker Hub - публичный реестр, который может использовать любой, можно запустить частный реестр.
![[Pasted image 20250319164004.png]]

Dockerfile
Место для описании инструкции по созданию образа Docker

Docker Image (образ докера)
Образ - шаблон доступный только для чтения, который создается из набора инструкций Dockerfile.
Образ определяет упакованное приложение и его зависимости, а так же какие процессы должны запускаться при его запуске. Каждая инструкция в Dockerfile добавляет новый слой к образу, причем слои представляют собой часть файловой системы образов, которая добавляет, либо заменяет слой под ним. Для управления слоев Docker использует Union File System.
!!!!!!!!!!!!Union file system можно представить как стековую файловую систему, то есть файлы и каталоги отдельных файловых систем (известных как ветви) могут быть прозрачно наложены друг на друга для формирования единой файловой системы. (система копирования при записи)

Преимущества многоуровневых систем:
- Отсутствие дублирования. Соли помогают избежать дублирования полного набора файлов каждый раз, когда используется образ для создания и запуска нового контейнера
- Разделение слоев. При изменении образа Docker распространяет обновления только на тот слой, который был изменен

Тома Docker (Docker Volumes)
Предпочтительны механизм постоянного хранения данных, потребляемых или производимых приложениями. Тома данных отделены от стандартной файловой системы Union File System и существуют как обычные каталоги и файлы в файловой системе хоста

Основные команды Docker

.dockerignore
Список файлов и папок, для игнорирования в ходе сборки образа

```
.git
node_modules
.env
*.log
```

Как писать Dockerfile
Инструкции как собирать образы на которых создаются контейнеры. Сообщает в каком порядке собирать слои в контейнеры, только для чтения. Начинается с `FROM` или `ARG` и потом `FROM`.  Только `RUN, COPY, ADD, CMD` создают слой, остальные создают временные промежуточные сборки и не увеличивают место сборки

```dockerfile
FROM python:3.7.2-alpine3.8 # указание базового (родительского) образа
LABEL maintainer="jeffmshale@gmail.com" # указание метаданных вида key=value
ENV ADMIN="jeff" # указание посоянные переменные среды
RUN apk update && apk upgrade && apk add bash # выполненеи команды, после выполения добавляется новый слой
# можно использовать shell-форму (apt update) или exec-форму (["executable", "param1", "param2"])
WORKDIR /app # изменяет рабочую директорию контейнера
ARG var=foo # задание перменной, значение которой можно передать из командной строки в образ во время его сборки. Отличие от ENV: переменные ARG недоступны вов время выполнения контейнера
COPY . ./app # берет файлы из локального контекста и добавляет их в текущую рабочую директорию образа, если директории нет, она будет создана

ENTRYPOINT ["python", "./app/my_script.py", "my_var"] # задание команды с аргументами, выполняемая при запуске контейнера. В отличии от CMD не перезаписывается если передана команда с аругментами. По докам использование exec-формы рекомендуется
EXPOSE 8000 # указание какие порты открыть для связи с контейнером (принудительно не открывает, просто указывает)
VOLUME /my_volume # указание иеста для постоянного хранения файлов 

ADD https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4 \ # разибиение на другую строку
/my_app_directory # схоже с COPY но позволяет добавлять файлы извне (URL)
RUN ["mkdir", "/a_directory"]
CMD ["python", "./my_script.py"] # выполнение команды при запуске контейнера. Может быть только 1 CMD
```

Как писать docker-compose.yaml

```bash
# Определение версии формата Compose (рекомендуется для совместимости)
version: '3.8'

services:
  # Пример сервиса для веб-приложения
  webapp:
    container_name: my_webapp  # Явное имя контейнера (удобно для управления)
    build: 
      context: .  # Путь к директории с Dockerfile
      dockerfile: Dockerfile  # Имя Dockerfile (по умолчанию ищет Dockerfile)
    ports:
      - "8000:8000"  # Проброс портов: <хост>:<контейнер>
    environment:
      - DEBUG=False  # Переменные окружения (можно задавать напрямую)
      - DATABASE_URL=postgresql://user:pass@postgres/dbname
    env_file: .env  # Загрузка переменных из файла (для секретов)
    depends_on:
      - postgres  # Зависит от сервиса postgres (но не ждет его готовности!)
    volumes:
      - static_volume:/app/static  # Монтирование тома
      - ./app:/app/code  # Монтирование локальной директории (bind mount)
    restart: unless-stopped  # Перезапуск при падении (кроме ручной остановки)
    healthcheck:  # Проверка работоспособности контейнера
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s  # Проверка каждые 30 секунд
      timeout: 10s   # Максимальное время ожидания ответа
      retries: 3     # Количество попыток перед признанием ошибки

  # Пример сервиса для PostgreSQL
  postgres:
    image: postgres:15-alpine  # Официальный образ (лучше указывать версию)
    container_name: my_postgres
    environment:
      POSTGRES_USER: ${DB_USER}  # Переменные из .env (защита секретов)
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: ${DB_NAME}
    ports:
      - "5432:5432"  # Проброс порта для внешнего подключения (опционально)
    volumes:
      - postgres_data:/var/lib/postgresql/data  # Постоянное хранилище данных
    healthcheck:  # Проверка доступности БД
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER} -d ${DB_NAME}"]
      interval: 10s
      timeout: 5s
      retries: 5
    deploy:  # Ограничение ресурсов (актуально в Swarm/Kubernetes)
      resources:
        limits:
          cpus: '0.5'  # Не более 50% CPU
          memory: 512M # Не более 512 МБ RAM

# Определение томов для постоянного хранения данных
volumes:
  static_volume:  # Том для статических файлов приложения
    driver: local
  postgres_data:  # Том для данных PostgreSQL (сохраняется при перезапуске)
    driver: local
```

По умолчанию Docker Compose создает **общую сеть** для всех сервисов в файле. Контейнеры могут общаться друг с другом по имени сервиса.
Можно явно указать пользовательские сети
```
services:
  web:
    image: nginx
    networks:
      - frontend

  backend:
    image: node:18
    networks:
      - frontend
      - backend

  db:
    image: postgres
    networks:
      - backend

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
```
- Сервисы `web` и `backend` находятся в сети `frontend`.
- Сервисы `backend` и `db` находятся в сети `backend`.

Драйвера сети:
- bridge - локальная сеть внутри хоста (по умполчанию)
- overlay - для кластеров docker swarm
- host - контейнер использует сеть хоста (отсутствует изоляция)
- none - отключение сети для контейнеров 
- macvlan - прямое назначение MAC-адреса контейнеру

