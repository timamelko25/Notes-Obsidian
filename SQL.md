- [Нормализация бд](#%D0%9D%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%B1%D0%B4)
	- [Пример нормализации](#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80%20%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8)
- [Ключевые команды](#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B)
	- [Выражение SELECT](#%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20SELECT)
	- [Условие WHERE](#%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5%20WHERE)
	- [**Условие DISTINCT** (исключение дубликатов)](#**%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5%20DISTINCT**%20(%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B4%D1%83%D0%B1%D0%BB%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D0%B2))
	- [**Условие AND/OR**](#**%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5%20AND/OR**)
	- [**Условие BETWEEN**](#**%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5%20BETWEEN**)
	- [**Условие IN**](#**%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5%20IN**)
	- [**Условие ORDER BY**](#**%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5%20ORDER%20BY**)
	- [**Условие GROUP BY**](#**%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5%20GROUP%20BY**)
	- [**Условие HAVING**](#**%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5%20HAVING**)
	- [**Условие LIKE**](#**%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5%20LIKE**)
	- [**Условие COUNT**](#**%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5%20COUNT**)
	- [**Выражение DROP TABLE**](#**%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20DROP%20TABLE**)
	- [**Выражение CREATE INDEX**](#**%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20CREATE%20INDEX**)
	- [**Выражение DROP INDEX**](#**%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20DROP%20INDEX**)
	- [**Выражение DESC** (сортировка в порядке убывания)](#**%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20DESC**%20(%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0%20%D0%B2%20%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D0%B5%20%D1%83%D0%B1%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))
	- [Выражение TRUNCATE](#%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20TRUNCATE)
	- [**Выражение ALTER TABLE**](#**%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20ALTER%20TABLE**)
	- [**Выражение ALTER TABLE + RENAME**](#**%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20ALTER%20TABLE%20+%20RENAME**)
	- [**Выражение INSERT INTO**](#**%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20INSERT%20INTO**)
	- [**Выражение UPDATE**](#**%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20UPDATE**)
	- [**Выражение DELETE**](#**%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20DELETE**)
	- [**Выражение CREATE DATABASE**](#**%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20CREATE%20DATABASE**)
	- [**Выражение DROP DATABASE**](#**%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20DROP%20DATABASE**)
	- [**Выражение BEGIN**](#**%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20BEGIN**)
	- [**Выражение COMMIT**](#**%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20COMMIT**)
	- [**Выражение ROLLBACK**](#**%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20ROLLBACK**)
	- [Выражение UNION](#%D0%92%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20UNION)
- [Типы данных](#%D0%A2%D0%B8%D0%BF%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
	- [**Целочисленные типы данных**](#**%D0%A6%D0%B5%D0%BB%D0%BE%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B8%D0%BF%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85**)
	- [**Типы данных с плавающей точкой**](#**%D0%A2%D0%B8%D0%BF%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D1%81%20%D0%BF%D0%BB%D0%B0%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B9%20%D1%82%D0%BE%D1%87%D0%BA%D0%BE%D0%B9**)
	- [**Время и дата**](#**%D0%92%D1%80%D0%B5%D0%BC%D1%8F%20%D0%B8%20%D0%B4%D0%B0%D1%82%D0%B0**)
	- [**Символы**](#**%D0%A1%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8B**)
	- [**Символы Unicode**](#**%D0%A1%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8B%20Unicode**)
	- [**Бинарные типы данных**](#**%D0%91%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B8%D0%BF%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85**)
	- [**Другие типы данных**](#**%D0%94%D1%80%D1%83%D0%B3%D0%B8%D0%B5%20%D1%82%D0%B8%D0%BF%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85**)
	- [**Логические операторы**](#**%D0%9B%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B**)
	- [Время](#%D0%92%D1%80%D0%B5%D0%BC%D1%8F)
- [**Виды объединений (JOIN)**](#**%D0%92%D0%B8%D0%B4%D1%8B%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9%20(JOIN)**)
- [Индексы](#%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B)
- [Виды](#%D0%92%D0%B8%D0%B4%D1%8B)
- [Транзакция](#%D0%A2%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F)
- [Временные таблицы](#%D0%92%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B)
- [SQL скрипты](#SQL%20%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D1%8B)
	- [Пример скрипта](#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80%20%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%B0)



***SQL*** (Structured Query Language) — *декларативный*(декларативный подход **предполагает подробное описание конечного результата**) язык программирования, применяемый для создания, модификации и управления данными в реляционной базе данных, управляемой соответствующей системой управления базами данных. Стандартный язык для - Систем Управления Реляционными Базами Данных - ***СУБД*** (*RDBMS related database management system*)


Среди преимуществ SQL мы можем выделить следующие:

- Позволяет пользователям получать доступ к данным в RDBMS.
- Позволяет пользователям описывать данные.
- Позволяет пользователям определять данные в БД и манипулировать ими.
- Позволяет встраивать другие языки, используя модули SQL, библиотеки и пре-компиляторы.
- Позволяет пользователям создавать и удалять БД и таблицы.
- Позволяет пользователю создавать встроенные виды, процедуры и функции в БД.
- Позволяет ограничивать доступ к таблицам, процедурам и видам.

Для наилучшей обработки запроса модуль управления (двигатель) SQL вычисляет, как интерпритировать задачу.

Используемые для этого компоненты:
- Query
- Dispatcher
- Optimization Engines
- Classic Query Engine
- SQL Query Engine

Classic Query обрабатывает все НЕ SQL запросы
SQL Query Engine не обрабатывает логические файлы


![[Pasted image 20250408220802.png]]


Стандартные SQL команды для взаимодействия с реляционными БД:

- CREATE
- SELECT
- INSERT
- UPDATE
- DELETE
- DROP

Эти команды делятся на 2 категории:
- **DDL – Data Definition Language**

|Команда|Описание|
|---|---|
|CREATE|Создаёт новую таблицу, вид таблицы или другой объект в БД.|
|ALTER|Изменяет существующий объект БД (например, таблицу).|
|DROP|Удаляет указанную таблицу, вид таблицы или другой объект БД.|
- **DML – Data Manipulation Language**

| Команда | Описание                                                     |
| ------- | ------------------------------------------------------------ |
| SELECT  | Получает определённые данные из одной или нескольких таблиц. |
| INSERT  | Создаёт запись                                               |
| UPDATE  | Изменяет записи                                              |
| DELETE  | Удаляет записи                                               |

Так же выделяется еще группа для выделения прав пользования
- **DCL – Data Control Language**

|Команда|Описание|
|---|---|
|GRANT|Даёт все привилегии пользователю|
|REVOKE|Отменяет привилегии отданные пользователю|

В СУБД данные хранятся в объектах, которые называются таблицами. ***Таблица*** - набор связанны по смыслу, состоящий из столбцом и рядом.

***Поле*** - колонка таблицы, цель которой - хранить определенную информацию о каждой записи в таблице

***Запись*** - каждый отдельный элемент, который хранится в таблице.

***Колонка*** - вертикальная сущность в таблице, которая содержит всю информацию, связанную с определенным полем таблицы.

***Констрейты SQL*** - набор правил, примененный к данным колонок в таблице. используются для ограничения типов данных, которые могут храниться в таблице, так же обеспечивает точность и читабельность данных в бд.

| Значение                                                                                       | Описание                                                                                                                                                         |
| ---------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [NOT NULL](http://proselyte.net/tutorials/sql/rdbms-basic-concepts/not-null-constraint/)       | [Гарантирует, что данная колонка не может иметь значение NULL.](http://proselyte.net/tutorials/sql/rdbms-basic-concepts/not-null-constraint/)                    |
| [DEFAULT](http://proselyte.net/tutorials/sql/rdbms-basic-concepts/constraint-default/)         | [Обеспечивает значение по умолчанию для колонки, в случае, если данные не указаны.](http://proselyte.net/tutorials/sql/rdbms-basic-concepts/constraint-default/) |
| [UNIQUE](http://proselyte.net/tutorials/sql/rdbms-basic-concepts/constraint-unique/)           | [Гарантирует, что все занчения в данной колонке уникальны.](http://proselyte.net/tutorials/sql/rdbms-basic-concepts/constraint-unique/)                          |
| [PRIMARY KEY](http://proselyte.net/tutorials/sql/rdbms-basic-concepts/constraint-primary-key/) | [Уникальный идентификатор каждой записи в таблице БД.](http://proselyte.net/tutorials/sql/rdbms-basic-concepts/constraint-primary-key/)                          |
| [FOREIGN KEY](http://proselyte.net/tutorials/sql/rdbms-basic-concepts/constraint-foreign-key/) | [Уникальный идентификатор записи в другой таблице БД.](http://proselyte.net/tutorials/sql/rdbms-basic-concepts/constraint-foreign-key/)                          |
| [CHECK](http://proselyte.net/tutorials/sql/rdbms-basic-concepts/constraint-check/)             | [Гарантирует, что все занчения в колонке соответствуют определённому условию.](http://proselyte.net/tutorials/sql/rdbms-basic-concepts/constraint-check/)        |
| [INDEX](http://proselyte.net/tutorials/sql/rdbms-basic-concepts/constraint-index/)             | [Используется для крайне быстрого создания и получения данных из БД.](http://proselyte.net/tutorials/sql/rdbms-basic-concepts/constraint-index/)                 |
| AUTOINCREMENT                                                                                  | Автоматическая нумерация                                                                                                                                         |
В каждой СУБД существуют следующие категории integrity (целостности данных)

| Значение                   | Описание                                                                                                |
| -------------------------- | ------------------------------------------------------------------------------------------------------- |
| Entity                     | В таблице нет повторяющихся данных.                                                                     |
| Domain                     | Использует валидные вводы для указанной колонки путём ограничения типа, формата или диапазона значений. |
| Referential                | Записи, которые используются другими записями, не могут быть удалены.                                   |
| Определённая пользователем | Использует некоторые специфические правила, которые не укладываются в три, указанные выше категории.    |

# Нормализация бд

Связи между таблицами:
1. **Один к одному**
2. **Многие к одному**
3. **Один ко многим**
4. **Многие ко многим**

*Основы нормализации бд*:
**Нормализация** - процесс организации данных в таблицах. Необходима для оптимального расхода памяти, изменение данных, согласованности данных. Третья форма является самым высоким уровнем. На практике разбиение на большое количество таблиц является целесообразным при частом изменении данных.

2 причины для процесса нормализации:
- выявление ненужных данных, например, хранение одних и тех же данных более, чем в одной таблице.
- Гарантирование того, что зависимости между данными имеют значение

**Первая нормальная форма**:
- Все атрибуты должны быть атомарными (т. е. не содержать списков, массивов или вложенных структур).
- В таблице не должно быть повторяющихся строк (записей).
- Должен быть определен первичный ключ, который уникально идентифицирует каждую запись.

**Вторая нормальная форма**:
- Должна быть выполнена 1NF.
- Все **неключевые атрибуты** должны **полностью зависеть** от **первичного ключа**.
- Если таблица имеет составной первичный ключ, то нельзя, чтобы часть этого ключа влияла только на часть данных (если такое есть — нужно выносить данные в отдельную таблицу).

**Третья нормальная форма**:
- Должна быть выполнена 2NF.
- **Не должно быть транзитивных зависимостей** (когда неключевые атрибуты зависят друг от друга, а не только от первичного ключа).
- Каждый неключевой атрибут должен зависеть **только** от первичного ключа.

**Иные формы**:
- Четвертая нормальная форма (BCNF):
	- Должна быть выполнена 3NF.
	- Каждый **детерминант** (атрибут, от которого зависят другие) должен быть **кандидатным ключом**.
	- Устраняются аномалии, когда один ключ частично определяет другой.
- Пятая нормальна форма - максимальное разбиение таблиц для избегания избыточности данных
	- Должна быть выполнена BCNF.
	- Таблица должна быть разложена так, чтобы можно было воссоздать исходные данные через соединение (JOIN), не порождая избыточность.
	- Часто применяется, когда данные содержат сложные связи многие-ко-многим.

## Пример нормализации

- *Первая нормальная форма*
❌ **Ненормализованная таблица (нет 1NF)**:

| ID  | Имя   | Телефон          |
| --- | ----- | ---------------- |
| 1   | Иван  | 111-222, 333-444 |
| 2   | Ольга | 555-666          |

✅ **Приводим к 1NF** (разбиваем многозначные атрибуты):

| ID  | Имя   | Телефон |
| --- | ----- | ------- |
| 1   | Иван  | 111-222 |
| 1   | Иван  | 333-444 |
| 2   | Ольга | 555-666 |

- *Вторая нормальная форма*

❌ **Нарушение 2NF** (данные о курсе зависят только от `Курс_ID`, а не от всего составного ключа):

|Студент_ID|Курс_ID|Название курса|Оценка|
|---|---|---|---|
|1|101|Математика|5|
|2|101|Математика|4|
|1|102|Физика|3|

✅ **Приводим к 2NF** (разносим данные в отдельные таблицы):

**Таблица "Оценки"**:

|Студент_ID|Курс_ID|Оценка|
|---|---|---|
|1|101|5|
|2|101|4|
|1|102|3|

**Таблица "Курсы"**:

| Курс_ID | Название курса |
| ------- | -------------- |
| 101     | Математика     |
| 102     | Физика         |

- *Третья нормальная форма*

❌ **Нарушение 3NF** (поле "Город" зависит от "Отдел_ID", а не от "Сотрудник_ID"):

|Сотрудник_ID|Имя|Отдел_ID|Отдел|Город|
|---|---|---|---|---|
|1|Иван|10|IT|Москва|
|2|Ольга|20|HR|Санкт-Петербург|

✅ **Приводим к 3NF** (выносим "Отдел" в отдельную таблицу):

**Таблица "Сотрудники"**:

|Сотрудник_ID|Имя|Отдел_ID|
|---|---|---|
|1|Иван|10|
|2|Ольга|20|

**Таблица "Отделы"**:

| Отдел_ID | Отдел | Город           |
| -------- | ----- | --------------- |
| 10       | IT    | Москва          |
| 20       | HR    | Санкт-Петербург |

- *Четвертая нормальная форма*

❌ **Нарушение BCNF** (у одного курса может быть несколько преподавателей и аудиторий, но преподаватель зависит только от курса):

|Курс|Преподаватель|Аудитория|
|---|---|---|
|Математика|Иван Петров|101|
|Математика|Ольга Иванова|102|

✅ **Приводим к BCNF** (разбиваем зависимости):

**Таблица "Курсы-Преподаватели"**:

|Курс|Преподаватель|
|---|---|
|Математика|Иван Петров|
|Математика|Ольга Иванова|

**Таблица "Аудитории"**:

| Курс       | Аудитория |
| ---------- | --------- |
| Математика | 101       |
| Математика | 102       |

- *Пятая нормальная форма*

❌ **Нарушение 5NF** (трёхсторонняя зависимость, таблица неразделена):

|Проект|Разработчик|Навык|
|---|---|---|
|CRM|Иван|Python|
|CRM|Иван|SQL|
|CRM|Ольга|Java|
|AI|Ольга|Python|

✅ **Приводим к 5NF** (разбиваем на три таблицы):

**Таблица "Проект-Разработчик"**:

|Проект|Разработчик|
|---|---|
|CRM|Иван|
|CRM|Ольга|
|AI|Ольга|

**Таблица "Разработчик-Навык"**:

|Разработчик|Навык|
|---|---|
|Иван|Python|
|Иван|SQL|
|Ольга|Java|
|Ольга|Python|

**Таблица "Проект-Навык"**:

| Проект | Навык  |
| ------ | ------ |
| CRM    | Python |
| CRM    | SQL    |
| CRM    | Java   |
| AI     | Python |

# Ключевые команды

Все SQL выражения начинаются с одного из следующих ключевых слов:

- **SELECT**
- **INSERT**
- **UPDATE**
- **DELETE**
- **ALTER**
- **DROP**
- **CREATE**
- **BEGIN**
- **SHOW**

В конце каждого выражения должна стоять точка с запятой “;”.

## Выражение SELECT

```

SELECT колонка1, колонка2 ...
FROM   имя_таблицы;
```

Для получения всех данных:
`SELECT * FROM   имя_таблицы;`

## Условие WHERE

```

SELECT колонка1, колонка2 ...
FROM   имя_таблицы
WHERE  условие;
```

**Условие WHERE**

```

SELECT колонка1, колонка2 ...
FROM   имя_таблицы
WHERE  условие;
```

## **Условие DISTINCT** (исключение дубликатов)

```

SELECT DISTINCT колонка1, колонка2 ...
FROM   имя_таблицы;
```

## **Условие AND/OR**

```

SELECT колонка1, колонка2 ...
FROM    имя_таблицы
WHERE  условие-1 {AND|OR} условие-2;
```

## **Условие BETWEEN**

```

SELECT колонка1, колонка2 ...
FROM   имя_таблицы
WHERE  имя_колонки BETWEEN значение-1 AND значение-2;
```

## **Условие IN**

```

SELECT колонка1, колонка2 ...
FROM   имя_таблицы
WHERE  имя_колонки IN (значение-1, значение-2);
```

## **Условие ORDER BY**

```

SELECT колонка1, колонка2 ...
FROM   имя_таблицы
WHERE  условие
ORDER BY имя_колонки {ASC|DESC};
```

## **Условие GROUP BY**

```

SELECT SUM(имя_колонки)
FROM   имя_таблицы
WHERE  условие
GROUP BY имя_колонки;
```

## **Условие HAVING**

```

SELECT SUM(имя_колонки)
FROM   имя_таблицы
WHERE  условие
GROUP BY имя_колонки
HAVING (условие);
```

## **Условие LIKE**

```

SELECT колонка1, колонка2 ...
FROM   имя_таблицы
WHERE  имя_колонки LIKE {шаблон}
```

## **Условие COUNT**

```

SELECT COUNT(имя_колонки)
FROM   имя_таблицы
WHERE  условие;
```


## **Выражение DROP TABLE**

```

DROP TABLE имя_таблицы;
```

## **Выражение CREATE INDEX**

```

CREATE UNIQUE INDEX имя_индекса
ON имя_таблицы ( клонка1, колонка2 ...);
```

## **Выражение DROP INDEX**

```
DROP INDEX имя_индекса;
```

## **Выражение DESC** (сортировка в порядке убывания)

```

DESC имя_таблицы;
```

## Выражение TRUNCATE

**Выражение TRUNCATE TABLE** (Удаляет все строки в таблице или указанные секции таблицы, не записывая в журнал удаление отдельных строк. `TRUNCATE TABLE` аналогично инструкции `DELETE` без `WHERE` предложения; `TRUNCATE TABLE` однако быстрее используется меньше системных и журналов транзакций. позволяет выставлять ряд условий (`WHERE`) для удаления определенных строк, использовать откат операций и отслеживать каждое удаление.)

```

TRUNCATE TABLE имя_таблицы;
```

## **Выражение ALTER TABLE**

```

ALTER TABLE имя_таблицы {ADD|DROP|MODIFY} имя_колонки {тип_данных};
```

## **Выражение ALTER TABLE + RENAME**

```

ALTER TABLE имя_таблицы RENAME TO новое_имя_таблицы;
```

## **Выражение INSERT INTO**

```

INSERT INTO имя_таблицы (колонка1, колонка2 ...)
VALUES ( значение1, значение2 ...);
```

## **Выражение UPDATE**

```

UPDATE table_name
SET колонка1 = значение1, колонка2 = значение2 ...
[ WHERE условие ];
```

## **Выражение DELETE**

```

DELETE FROM имя_таблицы
WHERE  {условие};
```

## **Выражение CREATE DATABASE**

```

CREATE DATABASE имя_базы_данных;
```

## **Выражение DROP DATABASE**

```

DROP DATABASE имя_базы_данных;
```

## **Выражение BEGIN** 
переключает контекст SQL-сессии на выбранную базу данных, и к ней будут применяться все последующие команды.

```

BEGIN имя_базы_данных;
```

## **Выражение COMMIT**

```

COMMIT;
```

## **Выражение ROLLBACK**

```
ROLLBACK;
```

## Выражение UNION

Для комбинирования результатов двух и более SQL запросов без возвращения повторяющихся данных используется оператор **UNION**. 
Для того, чтобы мы могли использовать данный оператор, каждый из запросов **SELECT** должен содержать одинаковое количество выбранных колонок, одинаковое количество выражений, одинаковые типы данных и иметь одинаковый порядок.
```
SELECT колонка1 [, колонка2 ]
FROM таблица1 [, таблица2 ]
[WHERE условие]

UNION

SELECT колонка1 [, колонка2 ]
FROM таблица1 [, таблица2 ]
[WHERE условие]
```

**Элемент UNION ALL**  
Элемент UNION ALL комбинирует результаты двух запросов **SELECT**, исключая повторяющиеся записи.  
Данный запрос имеет следующий вид:

```

SELECT колонка1 [, колонка2 ]
FROM таблица1 [, таблица2 ]
[WHERE условие]

UNION ALL

SELECT колонка1 [, колонка2 ]
FROM таблица1 [, таблица2 ]
[WHERE условие]
```

Существует два других оператора, чьё поведение крайне схоже с UNION:

- **INTERSECT**  
    Комбинирует два запроса SELECT, но возвращает записи только первого SELECT, которые имеют совпадения во втором элементе SELECT.
- **EXCEPT**  
    Комбинирует два запроса SELECT, но возвращает записи только первого SELECT, которые не имеют совпадения во втором элементе SELECT.

# Типы данных

## **Целочисленные типы данных** 

|Тип данных|От|До|
|---|---|---|
|bigint|-9,223,372,036,854,775,808|9,223,372,036,854,775,807|
|int|-2,147,483,648|2,147,483,647|
|smallint|-32,768|32,767|
|tinyint|0|255|
|bit|0|1|
|decimal|-10^38 +1|10^38 -1|
|numeric|-10^38 +1|10^38 -1|
|money|-922,337,203,685,477.5808|+922,337,203,685,477.5807|
|smallmoney|-214,748.3648|+214,748.3647|

## **Типы данных с плавающей точкой**

|Тип данных|От|До|
|---|---|---|
|float|-1.79E + 308|1.79E + 308|
|real|-3.40E + 38|3.40E + 38|

## **Время и дата**

|Тип данных|От|До|
|---|---|---|
|datetime|1 Января, 1753|31 Декабря, 9999|
|smalldatetime|1 Января, 1900|6 Июня, 2079|
|date|Хранит дату в формате May 30, 2016|   |
|time|Хранит время в формате 15:30 P.M.|   |

## **Символы**

|Тип данных|Описание|
|---|---|
|char|Максимальная длина – 8,000 символов. (Фиксированная длина символов, которые не входят в Unicode)|
|varchar|Максимальная длина – 8,000 символов. (Изменяющаяся длина данных, не входящих в Unicode).|
|varchar(max)|Максимальная длина – 231characters, Изменяющаяся длина данных, не входящих в Unicode (только для SQL Server 2005).|
|text|Изменяющаяся длина данных, не входящих в Unicode с максимальной длинной – 2,147,483,647 символов.|

## **Символы Unicode**

|Тип данных|Описание|
|---|---|
|nchar|Максимальная длина – 4,000 символов.( Фиксированная длина Unicode)|
|nvarchar|Максимальная длина – 4,000 символов.( Изменяющаяся длина Unicode)|
|nvarchar(max)|Максимальная длина – 231 символ. ( Изменяющаяся длина Unicode, только для SQL Server 2005)|
|ntext|Максимальная длина – 1,073,741,823 символов. ( Изменяющаяся длина Unicode)|

## **Бинарные типы данных**

|Тип данных|Описание|
|---|---|
|binary|Максимальная длина – 8,000 байтов.( Фиксированная длина бинарных данных)|
|varbinary|Максимальная длина – 8,000 байтов.( Изменяющаяся длина бинарных данных)|
|varbinary(max)|Максимальная длина – 231 байт.(Фиксированная длина бинарных данных. Только для SQL Server 2005)|
|image|Максимальная длина – 2,147,483,647 байтов. ( Изменяющаяся длина бинарных данных)|

## **Другие типы данных**

|Тип данных|Описание|
|---|---|
|sql_variant|Хранит значения различных типов данных, поддерживаемых сервером SQL, за исключением, text, ntext и timestamp.|
|timestamp|Хранит уникальное для базы данных значение, которое обновляется при каждом изменении записи.|
|uniqueidentifier|Хранит глобальный уникальный идентификатор (GUID)|
|xml|Хранит XML данные. Мы можем хранить экземпляр xml в колонке, либо в переменной ( Только для SQL Server 2005).|
|cursor|Хранит ссылку на курсор.|
|table|Хранит результирующее множество для крайней обработки.|

## **Логические операторы**

|Оператор|Описание|
|---|---|
|ALL|Используется для сравнения значения со всеми значениями в другом множестве значений.|
|AND|Разрешает существование нескольких условий в условии WHERE выражения SQL.|
|ANY|Сравнивает значение с любым применимым значением в списке в соответствии с условием.|
|BETWEEN|Ищет значения в указанном диапазоне.|
|EXISTS|Ищет запись в таблице, которая соответствует заданным критериям.|
|IN|Сравнивает значение в списке определённых буквенных значений.|
|LIKE|Сравнивает значение, которое похоже на определённый шаблон.|
|NOT|Делает логический оператор противоположным. Например, NOT IN, NOT EXISTS и т.д.|
|OR|Комбинирует несколько условий в SQL выражении.|
|IS NULL|Сравнивает значение с NULL.|
|UNIQUE|Проверяет каждую запись в таблице на уникальность.|

## Время

| **Name**                               | **Description**                                     |
| -------------------------------------- | --------------------------------------------------- |
| ADDDATE()                              | Добавляет дату                                      |
| ADDTIME()                              | Добавляет время                                     |
| CONVERT_TZ()                           | Конвертирует одну временную зону в другую.          |
| CURDATE()                              | Возвращает текущую дату.                            |
| CURRENT_DATE(), CURRENT_DATE           | То же самое, что и CURDATE.                         |
| CURTIME()                              | Возвращает текущее время                            |
| NOW()                                  | Возвращает текущие дату и время.                    |
| CURRENT_TIME(), CURRENT_TIME           | То же самое, что и NOW()                            |
| DATE_ADD()                             | Добавляет две даты                                  |
| DATE_FORMAT()                          | Определяет формат даты                              |
| DATE_SUB()                             | Разбивает две даты                                  |
| DATE()                                 | Возвращает только дату (число, месяц, год) из даты. |
| DATEDIFF()                             | Разделяет две даты                                  |
| DAY()                                  | То же самое, что и DAYOFMONTH()                     |
| DAYNAME()                              | Возвращает имя дня недели.                          |
| DAYOFMONTH()                           | Возвращает день месяца                              |
| DAYOFWEEK()                            | Возвращает индекс аргумента дня недели              |
| DAYOFYEAR()                            | Возвращает номер дня в году (1 – 366)               |
| EXTRACT                                | Выдаёт часть даты                                   |
| FROM_DAYS()                            | Конвертирует номер дня в дату.                      |
| FROM_UNIXTIME()                        | Форматирует дату в дата/время для UNIX систем.      |
| HOUR()                                 | Возвращает часы                                     |
| LAST_DAY                               | Возвращает крайний день месяца.                     |
| LOCALTIME(), LOCALTIME                 | То же самое, что и NOW()                            |
| LOCALTIMESTAMP, LOCALTIMESTAMP()       | То же самое, что и NOW()                            |
| MAKEDATE()                             | Создаёт дату из года и дня в году                   |
| MAKETIME                               | Создаёт время                                       |
| MICROSECOND()                          | Возвращает микросекунды                             |
| MINUTE()                               | Возвращает только минуты                            |
| MONTH()                                | Возвращает только месяц                             |
| MONTHNAME()                            | Возвращает имя месяца                               |
| CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP | Синоним для NOW()                                   |
| PERIOD_ADD()                           | Добавляет период для в месяце-году.                 |
| PERIOD_DIFF()                          | Возвращает количество месяцев в периоде.            |
| QUARTER()                              | Возвращает квартал                                  |
| SEC_TO_TIME()                          | Конвертирует секунды в формат ‘ЧЧ:ММ:СС’            |
| SECOND()                               | Возвращает секунды (0 – 59)                         |
| STR_TO_DATE()                          | Конвертирует строку в дату                          |
| SUBDATE()                              | То же самое, что и DATE_SUB() Требует три аргумента |
| SUBTIME()                              | Разделяет время                                     |
| SYSDATE()                              | Возвращает системное время                          |
| TIME_FORMAT()                          | Определяет формат времени                           |
| TIME_TO_SEC()                          | Конвертирует время в секунды                        |
| TIME()                                 | Возвращает время.                                   |
| TIMEDIFF()                             | Отделяет время                                      |
| TIMESTAMP()                            | Возвращает текущие дату и время.                    |
| TIMESTAMPADD()                         | Добавляет период дата/время                         |
| IMESTAMPDIFF()                         | Отделяет интервал из дата/время                     |
| TO_DAYS()                              | Конвертирует дату в дни                             |
| UNIX_TIMESTAMP()                       | Возвращает дату/время для UNIX систем               |
| UTC_DATE()                             | Возвращает дату UTC                                 |
| UTC_TIME()                             | Возвращает время UTC                                |
| UTC_TIMESTAMP()                        | Возвращает дату/время UTC                           |
| WEEK()                                 | Возвращает номер недели                             |
| WEEKDAY()                              | Возвращает индекс дня недели                        |
| WEEKOFYEAR()                           | Возвращает номер недели в году (1 – 53)             |
| YEAR()                                 | Возвращает год                                      |
| YEARWEEK()                             | Возвращает год и неделю                             |

|                    |                             |
| ------------------ | --------------------------- |
| Значение           | Ожидаемый формат            |
| MICROSECOND        | Микросекунды                |
| SECOND             | Секунды                     |
| MINUTE             | Минуты                      |
| HOUR               | Часы                        |
| DAY                | Дни                         |
| WEEK               | Недели                      |
| MONTH              | Месяцы                      |
| QUARTER            | Кварталы                    |
| YEAR               | Годы                        |
| SECOND_MICROSECOND | ‘Секунды.Микросекунды’      |
| MINUTE_MICROSECOND | Минуты.Микросекунды’        |
| MINUTE_SECOND      | ‘Минуты.Секунды’            |
| HOUR_MICROSECOND   | ‘Часы.Микросекунды’         |
| HOUR_SECOND        | ‘Часы.Секунды.Микросекунды’ |
| HOUR_MINUTE        | ‘Часы.Минуты’               |
| DAY_MICROSECOND    | ‘Дни.Микросекунды’          |
| DAY_SECOND         | Дни.Часы.Минуты.Секунды     |
| DAY_MINUTE         | Дни.Часы.Минуты             |
| DAY_HOUR           | Дни.Часы                    |
| YEAR_MONTH         | Года.Месяцы                 |

|                  |                                                                       |
| ---------------- | --------------------------------------------------------------------- |
| **Спецификатор** | **Описание**                                                          |
| %a               | Сокращённое имя дня недели                                            |
| %b               | Сокращённое имя месяца                                                |
| %c               | Номер месяца                                                          |
| %D               | День месяца с английским суффиксом                                    |
| %d               | Номер дня в месяце (00 … 31)                                          |
| %e               | Номер дня в месяце (0 … 31)                                           |
| %f               | Микросекунды (000000 … 999999)                                        |
| %H               | Часы (00 … 23)                                                        |
| %h               | Часы (01 … 12)                                                        |
| %I               | Часы (01 … 12)                                                        |
| %i               | Минуты (00 … 59)                                                      |
| %j               | Дни года (001 … 366)                                                  |
| %k               | Часы (00 … 23)                                                        |
| %l               | Часы (1 … 12)                                                         |
| %M               | Имя месяца                                                            |
| %m               | Номер месяца                                                          |
| %p               | AM или PM                                                             |
| %r               | Время с использованием AM или PM                                      |
| %S               | Секунды (00 … 59)                                                     |
| %s               | Секунды (00 … 59)                                                     |
| %T               | Время (ЧЧ:ММ:СС)                                                      |
| %U               | Неделя (00 … 53). Первый день недели – Воскресенье                    |
| %u               | Неделя (00 … 53). Первый день недели – Понедельник                    |
| %V               | Неделя (00 … 53). Первый день недели – Воскресенье. Используется с %X |
| %v               | Неделя (00 … 53). Первый день недели – Понедельник. Используется с %x |
| %W               | День недели                                                           |
| %w               | День недели (0 – Воскресенье … 6 – Суббота)                           |
| %X               | Год для недели. Воскресенье – первый день недели. Используется с %V   |
| %x               | Год для недели. Понедельник – первый день недели. Используется с %v   |
| %Y               | Год  (YYYY)                                                           |
| %y               | Год (YY)                                                              |
| %%               | Символ .%.                                                            |
| %x               | То же самое для любых элементов, указанных выше                       |

# **Виды объединений (JOIN)**

- **[INNER JOIN](http://proselyte.net/tutorials/sql/sql-using-joins/sql-using-inner-join/):**  
    возвращает записи, когда имеются совпадения в обоих таблицах
- **[LEFT JOIN](http://proselyte.net/tutorials/sql/sql-using-joins/sql-using-left-join/):**  
    возвращает записи из левой таблицы даже если нет совпадений в правой.
- **[RIGHT JOIN](http://proselyte.net/tutorials/sql/sql-using-joins/sql-using-right-join/):**  
    возвращает все записи из правой таблицы, даже если нет совпадений в левой.
- **[FULL JOIN](http://proselyte.net/tutorials/sql/sql-using-joins/sql-using-full-join/):**  
    возвращает записи, когда есть совпадение, хотя бы в одной из таблиц.
- **[SELF JOIN](http://proselyte.net/tutorials/sql/sql-using-joins/sql-using-self-join/):**  
    используется для объединения таблицы с ней самой, таким образом, как будто первая таблица является и второй, временно переименовывая хотя бы одну из таблиц в SQL запросе.

![[Pasted image 20250409013536.png]]

# Индексы

***Индексы*** - специальные таблицы, которые могут быть использованы поисковым двигателем бд, для ускорения получения данных. Необходимо добавить указатель индекса в таблицу. Ускоряет запросы на получение данных (SELECT \[WHERE]), но замедляет процесс добавления и изменения записей (INSERT, UPDATE). Индексы могут быть добавлены или удалены без влияния на данные.

Для добавления индекса, используется команда CREATE INDEX, где указывается имя индекса и определение таблицы, колонки или индекс колонки и определяется используется ли индекс по возрастанию или убыванию.

Индексы также могут быть уникальными.

```
CREATE INDEX имя_индекса ON имя_таблицы;
```

```
CREATE INDEX имя_индекса
ON имя_таблицы (имя_колонки);
```

```

CREATE INDEX имя_индекса
ON имя_таблицы (колонка1, колонка2);
```

Выбор типа индекса (одноколоночный или многоколоночный) зависит, что будет использовано с оператором WHERE.

Для удаления индекса

```
DROP INDEX имя_индекса;
```

Когда лучше обойтись без индексов:
- небольшие таблицы
- таблицы с частым изменением/добавлением данных
- много значений NULL в таблице


# VIEW (Виды)

***Вид*** (View) - SQL запрос, который хранится в бд с определенным именем. Это таблица которая хранится в форме предопределенного SQL запроса. 

*Использование*:
- структурирование данных наиболее удобным способом
- ограничение доступа к данным
- сбор данных из нескольких таблиц для генерации отчетов

Для создания вида используется **CREATE VIEW.**

```
CREATE VIEW имя_вида AS
SELECT колонка1, колонка2.....
FROM имя_таблицы
WHERE [условие];
```

На изменение вида накладываются определённые ограничения:

- SELECT не может содержать функций подсчёта.
- SELECT не может содержать функций присваивания.
- SELECT не может содержать ключевое слова DISTINCT
- SELECT не может содержать условие ORDER BY
- FROM не может содержать несколько таблиц
- Запрос не может содержать HAVING или GROUP BY
- WHERE не может содержать подзапросов
- Все колонки NOT NULL из базовой таблицы должны быть включены в вид для запроса INSERT
- Вычисленные колонки не могут быть изменены

Для удаления вида:
```
DROP VIEW имя_вида;
```


# Транзакция

***Транзакция*** является рабочей единицей работы с бд. Это последовательность операций, выполняемых в логическом порядке пользователем, либо программой, которая работает с БД.

Основные концепции транзакции описываются аббревиатурой ACID.

Для управления транзакциями используются команды:
- COMMIT
- ROLLBACK
- SAVEPOINT - создание точки к которой группа транзакций может откатиться
- SET TRANSACTION - размещает имя транзакции

Используется только для *DML* команд: INSERT, UPDATE, DELETE. Не могут быть использованы во время создания, изменения или удаления таблицы.

Пример:
Отключение автоматическое выполнение транзакции:
```
SET autocommit=0;
```

```
DELETE FROM developers 
       WHERE SPECIALTY = 'C++';
```

```
COMMIT;
```

```
ROLLBACK;
```

```
SAVEPOINT SP1;
```

```
ROLLBACK TO SP1;
```

```
RELEASE SAVEPOINT SP1;
```

**SET TRANSACTION** используется для инициировании транзакции бд. Позволяет определить характеристики транзакции.

```
SET TRANSACTION READ ONLY;
```

```
SET TRANSACTION READ WRITE;
```


# Временные таблицы

Используются для хранения и обработки промежуточных результатов. Полезны для хранения временных данных (список товаров в чеке, до момента осуществления оплаты). Удаляются сразу после завершения клиентской сессии.

```
CREATE TEMPORARY TABLE SALES_TICKET_SUMMARY (
          PRODUCT_NAME VARCHAR (100) NOT NULL, 
          PRODUCT_PRICE INT NOT NULL, 
          PRODUCT_AMOUNT INT NOT NULL DEFAULT 1
        );
```



# SQL скрипты

файл с расширением .sql содержащий набор инструкций SQL, которые могут выполняться в бд.

## Пример скрипта
```sql
-- turn off parallel queries
alter system set max_parallel_workers_per_gather=0;
-- apply changes
select pg_reload_conf();

-- t1 table has 10e7 rows
create table if not exists t1 as
 select a.id as id
      , cast(a.id - floor( random() *(a.id) ) as integer ) as parent_id
      , substr( md5( random()::text ), 0, 30 )  as name
 from generate_series ( 1, 10000000 ) a(id);

-- t2 table has 5*10e6 rows
create table if not exists t2  as
select row_number() over() as id
     , id as t_id
     , to_char(date_trunc('day', now()- random()*'1 year'::interval),'yyyymmdd') as day
from t1
order by random() 
limit 5000000;

```