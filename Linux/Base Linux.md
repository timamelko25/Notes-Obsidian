[[Bash Scripts basics]]
[[Commands]]
[[Arch Install Dual Boot]]

- [sysfs, devfs, udev](#sysfs,%20devfs,%20udev)
	- [Devfs](#Devfs)
	- [Sysfs](#Sysfs)
	- [Procfs](#Procfs)
	- [Вывод списка оборудования](#%D0%92%D1%8B%D0%B2%D0%BE%D0%B4%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0%20%D0%BE%D0%B1%D0%BE%D1%80%D1%83%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
	- [Управление модулями ядра](#%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8F%D0%BC%D0%B8%20%D1%8F%D0%B4%D1%80%D0%B0)
- [Процесс загрузки Linux](#%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%20%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B8%20Linux)
	- [Система инициализации ОС](#%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0%20%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8%20%D0%9E%D0%A1)
		- [SysV](#SysV)
		- [Systemd](#Systemd)
		- [Upstart](#Upstart)
	- [Разбиение жесткого диска](#%D0%A0%D0%B0%D0%B7%D0%B1%D0%B8%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B6%D0%B5%D1%81%D1%82%D0%BA%D0%BE%D0%B3%D0%BE%20%D0%B4%D0%B8%D1%81%D0%BA%D0%B0)
		- [LVM (Logical Volume Manager)](#LVM%20(Logical%20Volume%20Manager))
	- [Загрузчики linux](#%D0%97%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA%D0%B8%20linux)
	- [Командные оболочки](#%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D1%8B%D0%B5%20%D0%BE%D0%B1%D0%BE%D0%BB%D0%BE%D1%87%D0%BA%D0%B8)
	- [Работа с процессами](#%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D1%81%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0%D0%BC%D0%B8)
	- [Управление квотами дисков](#%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B2%D0%BE%D1%82%D0%B0%D0%BC%D0%B8%20%D0%B4%D0%B8%D1%81%D0%BA%D0%BE%D0%B2)
	- [Права доступа](#%D0%9F%D1%80%D0%B0%D0%B2%D0%B0%20%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0)
	- [Мягкие и жесткие ссылки](#%D0%9C%D1%8F%D0%B3%D0%BA%D0%B8%D0%B5%20%D0%B8%20%D0%B6%D0%B5%D1%81%D1%82%D0%BA%D0%B8%D0%B5%20%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8)

# sysfs, devfs, udev

HAL (hardware abstracted level) (deprecated) - абстракция железа для ОС. Идет обращение не к конкретному железу а его виртуальному представлению.
Dbus - программная шина позволяющая работать процессам между собой, так же можно получить информацию о железе и передать софту
Udev - современный менеджер устройств

Преимущества udev:
- работает на уровне пользователя (есть уровень ядра)
- управляется событиями (подключение флешки к системе)
- понятные файлы конфигов
- держит в системе только файлы активных устройств
- сохраняет имена устройств при переподключении

## Devfs
Devfs - использовавшаяся в прошлом виртуальная файловая система, функционал которой перешел в udev. Вся находится в оперативной памяти. Монтируется в /dev. 
- mem - образ физической памяти ПК
- null - пустое устройство
- pts/ - псевдотерминалы
- urandom - генератор случайных чисел
- sdx - блочные устройства
- tty - аппаратные терминалы

l - link
d - dir
b - блочное устройство - отправляет данные блоками
с - символьное устройство - поток данных

## Sysfs
Sysfs - виртуальная файловая система, экспортирует информацию о драйверах и устройствах на уровень пользователя. Монтируется в /sys.
- devices/ - все устройства, зарегистрированные в ядре
- bus/ - перечень шин (подсистема для передачи между функциональными блоками)
- drivers/ - драйверы
- block/ - каталог блочных устройств (носители информации, нужно устройство и драйвер к нему)
- class/ - группировка устройств по классам

## Procfs
Procfs - виртуальная файловая система, иерархическое представление всех процессов в системе. Монтируется в /proc
- PID/ - информация о конкретном процессе
- cpuinfo/ - сведения о ЦПУ
- devices/ - перечень настроенных устройств
- mounts/ - смонтированные файловые системы
- sys/ - доступная для редактирования информация о системе

## Вывод списка оборудования
- `lsmod` - модули ядра, присутствуют драйверы
- `lspci` - устройства PCI
- `lspcmcia` - устройства PCMCIA
- `lsusb` - шина USB
- `lshal` (deprecated)
- `lshw` - детальная информация о комплектующих

Опции `udevadm`
- info - получение информации из БД
- trigger - запросить события для устройства
- settle - дождаться завершения обработки
- control - управление демоном
- monitor - следить за событиями
- test - симулировать запуск события

## Управление модулями ядра
- `lsmod`
- `modinfo` - информация о конкретном модуле
- `rmmod` - удаление модуля ядра
- `insmod` - установка модуля ядра
- `modprobe` (современный) - деликатное удаление или добавление модулей

# Процесс загрузки Linux

1. BIOS/UEFI - запуск системы, при запуске системы процессор переходит на адрес биоса и загружает биос. Система проходит проверки и выбирает устройство информации
2. MBR/GPT - первая  стадия загрузки, устройство на котором ищется загрузчик
3. LILO/GRUB - вторая стадия загрузки, загрузчик ищет ядро, загружает его
4. Linux Kernel - дальнейшая часть переходит ядру для инициализации устройств
5. Init - пользовательская инициализация

## Система инициализации ОС
### SysV (old)
Init в стиле SysV (old) - родительский процесс инициализации системы на одном из заданных уровней запуска (runlevel 7 шт). Для изменения runlevel по умолчанию `/etc/inittab`

runlevel - режимы функционирования системы.
0. выключение
1. однопользовательский режим
2. Debian/Ubuntu режим работы по умолчанию (GUI/консоль)
3. RedHat/Suse по умолчанию текстовый режим
4. WikdCard (программируемый режим)
5. RedHat/Suse - GUI
6. перезагрузка

Основные команды для управления инициализацией
- init - управление инициализацией
- telinit - управление процессом init
- wall - вывод сообщения пользователям системы
- halt - выключение операционной системы
- reboot - перезагрузка компьютера
- shutdown - запланированное выключение
- service service_name start/stop/reload (с учетом измененных конфигов)/restart
### Systemd
Init в стиле systemd - родительский процесс инициализации системы в ускоренном режиме, за счет параллельного запуска задач. управление запущенными демонами через `systemctl` 

`/usr/lib/systemd` - директория с юнитами по умолчанию
`/etc/systemd` - директория с управляемыми юнитами

Unit-модули, которыми оперирует systemd:
- .service
- .mount
- .device
- .socket
- .target - позволяет работать с runlevel
	- poweroff.target
	- rescue.target
	- multi-user.target
	- graphical.target
	- reboot.target

`journald` - демон журнала
### Upstart
Init в стиле Upstart - родительский процесс инициализации системы на основе отслеживания событий

service, task - то, чем оперирует upstart
`/etc/init` - каталог файлов-заданий (job)
`initctl` - утилита управления upstart

## Разбиение жесткого диска

Директории которые могут быть смонтированы как отдельные разделы жесткого диска (физически может находиться не на 1 диске):
- /
- /boot
- /home - можно монтировать через сервер
- /root
- /etc
- /opt/ - ПО от третьих поставщиков
- /var
- /usr - все установленные пакеты программ, документация, исходных код ядра
- /tmp

- Swap (раздел подкачки) - никуда не монтируется

Структура жесткого диска

![[Pasted image 20250521140342.png]]

Можно создать только 4 основных раздела (primary), если необходимо больше то нужно создать расширенный (extended), который будет состоять из логических (logical).
sda 1-4 только для основных, логические начинаются с 5...

`Fdisk` - разбиение жесткого диска
`Mkfs` - создание файловой системы

`swapon` `swapoff` - работа с разделом подкачки
`/etc/fstab` - конфигурационный файл, отвечающий за монтирование файловых систем

### LVM (Logical Volume Manager)
Система управления томами. Поверх физических разделов можно создать логические разделы

![[Pasted image 20250521141944.png]]

##  Загрузчики linux
MBR - Master boot record - первые 512 байт диска (не раздел), участок зарезервированный для загрузчика системы и таблицы разделов.
При UEFI диск будет разбит по принципу GPT (guide partition table). Используется логические блоки адресов
![[Pasted image 20250521151337.png]]

## Командные оболочки
bash - bourne again shell
sh
zsh
fish

`cat /etc/passwd`

`.profile` - пользовательские настройки
`.bashrc` - детальные настройки

При входе пользователя идет левая часть инициализации, если вне пользовательского контекста то правая часть. Обработка файлов идет сверху вниз. Есть еще `.bashrc_history` `.bashrc_logout`

![[Pasted image 20250531200617.png]]

можно создавать `alias` и `functions`

```
functoin hel() {
echo "hello world";
}
```

Аргументы функции
- $0 - имя функции
- $1 - номер передаваемого аргумента

Передача вывода команды в аргумент
$(ls -a)
\`ls -a\`

Переменные - работают в пределах текущей оболочки
Переменные среды - работают так же во всех дочерних процессах
- `set` - вывод всех переменных и функций
- `unset` - удаление переменных
- `export` - изменение переменной в переменную среды
- `env` - вывод переменных сред
## Потоки ввода и вывода
Выделяется 3 потока:
- stdin - 0
- stdout - 1
- stderr - 2

- **< file** — использовать файл как источник данных для стандартного потока ввода.
- **> file** — направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху.
- **2> file** — направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху.
- **>>file** — направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.
- **2>>file** — направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.
- **&>file** или **>&file** — направить стандартный поток вывода и стандартный поток ошибок в файл. Другая форма записи: **>file 2>&1**.

Команды со знаками **>** или **<** означают перезапись существующего содержимого файла:

- **>** — стандартный вывод,
- **<** — стандартный ввод,
- **2>** — стандартная ошибка.

Команды со знаками **>>** или **<<** не перезаписывают существующее содержимое файла, а присоединяют данные к нему:

- **>>** — стандартный вывод,
- **<<** — стандартный ввод,
- 2**>>** — стандартная ошибка.

Каналы `|` используются для перенаправления потока из одной программы в другую. Стандартный вывод данных после выполнения одной команды перенаправляется в другую через канал. Данные первой программы, которые получает вторая программа, не будут отображаться. На дисплей терминала будут выведены только отфильтрованные данные, возвращаемые второй командой.

`env` - переменные среды (переменные)

вывод в `ls`
`.` - текущая директория
`..` - подняться на уровень выше
`export` - добавить в переменные среды переменные
`unset` - отменить переменную
`uname` - просмотр текущей ОС
`whatis` - просмотр информации о бинарниках
`file` - просмотр информации о файле
`stat`
`history` - история выполненных команд
`man` - --help
`exec command` - выполнить команду игнорируя настроенные конфиги (необходимо заново загрузить конфиги)
`dd` - создание резервной копии девайса

`*` - замена на любое количество символов
`?` - заменяет только 1 символ 
`[]` - диапазон количества
`[ac]` - a or c
`{}` - последовательность для подстановки в команду

## Процессы

Процесс - программа, выполняющаяся в оперативной памяти компьютера. Каждая программа может запустить множество процессов. В единственный момент на машине, выполняется только 1 процесс. Очередью в которой процессу выделяется определенный ресурс железа, управляет планировщик. При этом, во время прерывания одного процесса и запуска (возобновления) другого процесса, состояние процесса (выполняемые действия, на каком этапе приостановлен) запоминается и область памяти.

Планировщик в Linux - часть ядра, отвечающая за указанную функциональность. В задачи планировщика так же входит отслеживание и выделение запускаемым процессам определенного приоритета, чтобы процессы могли работать вместе, а так же распределение пространства памяти, чтобы пространство памяти одного процесса не пересекалось с пространством другого.

Все новые процессы в Linux порождаются клонированием какого-то уже имеющегося процесса, с помощью вызова системных функций `clone` и `fork`. У нового (порожденного или дочернего) процесса тоже окружение, что и у родителя, отличается только номер ID процесса (PID). PPID – идентификатор процесса, породившего данный

Первый процесс в системе запускается при инициализации ядра. Данный процесс называется `init` и имеет PID = 1. Это прородитель всех процессов в системе

Состояние процессов:
- Активен (R=Running) - процесс находится в очереди на выполнение, то есть либо выполняется в данный момент, либо ожидает выделения ему очередного квантра времени ЦП
- Спит (S=Sleeping) - процесс находится в состоянии прерываемого ожидания, то есть ожидает какого-то события, сигнала или освобождение нужного ресурса
- Непрерывное ожидание (D=Direct) - процесс ожидает определенного (прямого) сигнала от аппаратной части и не реагирует на другие сигналы
- Приостановлен (T) - процесс находится в режиме трассировки (обычно при дебаге)
- Зомби (Z=Zombie) - процесс, выполнение которого завершилось, но относящиеся к нему структуры ядра по каким-то причинам не освобождены

###  Межпроцессный обмен

Средства межпроцессного взаимодействия (Interprocess Communication - IPC),  которые можно разбить на несколько уровней:
- локальный (привязаны к процессу и возможны только в пределах компьютера)
	- каналы
		- pipe (конвейеры, так же неименованные каналы) - используется stderr, stdin, stdout
		- именованные каналы (FIFO) - создается с помощью `mknod` `mkfifo` и 2 различных процесса могут обратиться к нему по имени
	- сигналы - асинхронное уведомление процессора о каком-либо событии. Когда сигнал послан процессу, ОС прерывает выполнение процесса. Если процесс установил собственный обработчик сигнала, ОС запускает этот обработчик, передав ему информацию о сигнале. Числовые сигналы процессов определяются в `signal.h`
	- разделяемая память - в обычной ситуации обмен информацией между процессами проходит через ядро. Техника разделения памяти позволяет осуществить обмен информацией не через ядро, а используя некоторую часть виртуального адресного пространства. После создания разделяемого сегмента памяти любой из пользовательских процессов может подсоединить его к своему собственному виртуальному пространству и работать с ним, как с обычным сегментом памяти
	- очереди сообщений - один процесс помещает сообщение в очередь посредством неких системных вызовов, а любой другой процесс может прочитать его оттуда
- удаленный 
	- RPC (Remote Procedure Calls) - разновидность технологий, которая позволяет компьютерным программам вызывать функции или процедуры в другом адресном пространстве
	- сокеты Unix - бывают 2-ух типов: локальные, сетевые. При использовании локального сокета, ему присваивается UNIX-адрес и просто будет создан специальный файл (файл сокета) по заданному пути, через который смогут сообщаться любые локальные процессы путем чтения/записи из него. Сокеты представляют собой виртуальный объект, который существует, пока на него ссылается хотя бы один из процессов. При использовании сетевого сокета, создается абстрактный объект привязанный к слушающему порту операционной системы и сетевому интерфейсу, ему присваивается INET-адрес, который имеет адрес интерфейса и слушающего порта
## Работа с процессами
Задачи работают в fg (foreground) и bg (background)
nohup (no hang up) - позволяет оставлять процессы работающими после выхода пользователя из системы

`command &` - перевод команды в фоновый режим

- `ps aux`
- `pstree`
- `pgrep` - поиск процессов
- `pkill`
- `top`
- `free` - загрузка оперативной памяти
- `uptime`
- `screen` - управление сессии

Приоритет для любого процесса от -20 до +19 (freeBSD +20)
-20 - является максимальным приоритетом с максимальным выделением ресурсов, +19 минимальный
`Nice` и `Renice` изменение приоритета для процесса

Regexp
\\btext - слова начинается с text
text\\b - слова заканчивающиеся на text
^ - начало строки
$ - конец строки 
\[a-z] - диапазон от a до z
\[^t] - не буква t
\\\[ - ввод конкретного символа
. - любой символ
a|z - a или z

`grep`
- -n - нумерация строк
- -i - игнорирование регистра

## Управление квотами дисков
Квоты - установление ограничений для дисков
Блоки в диске - количество 1 килобайтныз блоков
soft квота - пользователь может превысить, но не больше чем на неделю
hard квота - нельзя превысить
inode - число созданных файлов, папок
Inode (Index Node) в Linux - это структура данных, которая хранит информацию о файле или каталоге, такую как его владелец, права доступа, дата и время создания и изменения, размер и расположение на жестком диске. Каждый файл или каталог в системе имеет свой уникальный номер индексного узла (inode number), который можно использовать для выполнения различных операций с файлом или каталогом.

`ls -i` - просмотр inode файлов
`find / -inum 123` - поиск файла по inode
`df -i` - просмотр сколько занято inode

## Права доступа
`chown` - смена владельца
`chgrp` - установка группы владельцев
`chmod` - установка прав доступа

Любой объект файловой системы имеет:
- Владельца (**u**ser)
- Группу владельцев (**g**roup)
- Остальных (**o**thers)

`/etc/passwd` - просмотр всей информации по пользователям и группам
имя_пользователя:пароль:uid:gid:сведения:домашняя_папка:оболочка
`/etc/group`
имя_группы:пароль:gid:член_группы

Технология теневых паролей нужна для скрытия паролей пользователей, потому что системные службы обращаются в эти папки и просматривают содержимое

![[Pasted image 20250601170315.png]]

`id username` - посмотреть id пользователя и всю информацию по нему
`chown :group` - поменять группу у файла

Вес прав доступа
- e**x**ecute=1
- **w**rite=2
- **r**ead=4
`chmod u+w script` - дать права записи владельцу
`chmod ugo-x script` - отобрать у всех право выполнения файла

Маска создания файлов и папок
Маска - с какими правами по умолчанию будут создаваться объекты. Указывается по принципу вычитания из максимальных прав 777 для папки, 666 для файла.
`umask 022` - все папки будут создаваться с разрешением 777-022=755 (rwxr-xr-x)

`umask` - маска создания файлов и директорий 

`suid` (4) - бит запуска от имени владельца (подмена пользователя на владельца файла)
`sgid` (2) - бит запуска от имени группы владельцев. Меняет все подфайлы папки на группу папки
`sticky` (1) - бит защиты содержимого, для папок

`chmod u+s sript` - установка suid
`chmod g+s script` - sgid
`chmod o+t script` - sticky

`useradd` - создать пользователя
`usermod` - изменить свойства пользователя
`userdel` - удалить пользователя

## Мягкие и жесткие ссылки

Softlink (symlink) - ярлык, весит 8 килобайт, опирается на имя (после переименования не найдет файл). Можно создать ссылку на папку. Лучше указывать полный путь к файлу, для избежания битых ссылок
Hardlink - ссылается на тот же inode файла, весит как исходных файл.  Нельзя создать ссылку на файл находящийся на другом физическом устройстве, на папку нельзя создать ссылку

`ln filename hard` - создание hardlink
`ln -s filename soft` - создание symlink

## Менеджеры дисплея
gdm - gnome display manager
kdm - kde display manager
xdm - X display manager
lightdm

`/etc/X11` - для xorg

## Конфигурационные файлы сети

При проверке запроса в DNS сначала идет просмотр `/etc/hosts`, дальше смотрится кеш DNS, дальше проверка основного сервера DNS, дополнительный сервер DNS смотрится бд и кеш.

`/etc/hostname` - имя узла
`/etc/hosts` - база данных имен и ip-адресов
`/etc/resolve.conf` - настройка DNS. search domain взаимозаменяемые и берется последняя записьд  
`/etc/nsswitch.conf` - настройка NSS (Name Service Switch)

`route` - таблица маршрутизации, простейшая форма правил маршрутизации, текстовый файл, который описывает сетевые маршруты для сетевых интерфейсов
metric - уровень предпочтительности пути
target - IP адрес цели
gateway - IP адрес шлюза
source - IP отправителя 
протокол
сетевой интерфейс

# Управление памятью в Linux

Memory managment - в основном подразумевает обработку запросов к памяти от процессов, выделение и освобождение блоков памяти, а также обеспечение ее эффективного использования.

Ключевые понятия:
- Виртуальная память - сброс неиспользуемых блоков памяти приложений на диск и тем самым расширение использования памяти для приложений
- Системы страница (Paging) - физическая и виртуальная память разделены на блоки фиксированного размера, которые называются страницами. Система страниц позволяет эффективно управлять памятью и активирует механизм обмена данными между ОЗУ и диском (swap)
- Выделение памяти (Memory Allocation) - выделение процессам подходящий блоков памяти отвечает соответствующий диспетчер. Память выделяется из свободной физической памяти. При необходимости физическая память освобождается сбросом неактивных страниц на диск
- Пространство ядра и пользовательское пространство (Kernel Space and User Space) - пространство ядра зарезервировано для исполнения кода ядра, расширений ядра и большинства драйверов устройств. Пользовательское пространство - область памяти, с которой работают все пользовательские приложения
- Кеширование (Caching) - используется кеш страниц (page cache) для кеширования файлов, читаемых с диска, кеш буфера (buffer cache) используется для управления операциями записи на диск
- Чрезмерное выделение памяти (Memory Overcommit) - позволяет большему количество процессов выполняться одновременно при условии что процессы не используют всю выделенную им память

## Как работает виртуальная память

- Сегментация памяти (Memory Segmentation)
При запуске приложения ему выделяется диапазон адресов виртуальной памяти. Эта память разделена на блоки (chunks), называемые страницами.
- Таблица страниц (Page Tables)
Операционная система сохраняет для каждого процесса структуру данных, которая называется таблицей страниц. Таблица страниц сопоставляет адреса страниц виртуальной памяти с адресами страниц физической памяти
- Доступ к памяти (Memory Access)
Когда приложение выполняет запрос на чтение или запись к памяти, ЦПУ используется таблицу страниц для трансляции адреса виртуальной памяти в адрес физической
- Подкачка и запрос страниц (Swapping and Demand Paging)
Если вся физическая память использована, а приложению требуется загрузить новую страницу в нее, то ОС может выбрать страницу физической памяти для сброса (подкачки) (swap out) на диск. В таблицу страниц вносится пометка, что данная страница отсутствует в физической памяти. Если позднее приложение попытается получить доступ к адресу выгруженной на диск страницы, то это приведет к ошибке и ОС загрузит (подкачает) (swap in) страницу с диска в физическую память (возможно сбросив при этом на диск другую страницу), после чего приложение сможет получить к ней доступ. Механизм загрузки страниц в физическую память при обращении называется demand paging и позволяет общему объему виртуальной памяти для всех процессов превышать объем фактически доступной физической памяти. 

![[Pasted image 20250607190444.png]]
## Translation Lookaside Buffer

Встроенная функция в современных процессорах для поиска страниц для трансляции адресов. TLB по сути является небольшим кешем.

## Анализ использования памяти

`free`

`top`

`vmstat`

`/proc/meminfo`


# Процессор

## Анализ использования процессора

`top`

%CPU:
- us (user) - использование процессора в пользовательском режиме
- sy (system) - использование системы ядра 
- ni (nice) - выполнение операций с измененным приоритетом
- id (idle) - время простоя процессора
- wa (io wait) - ожидание процессов ввода-вывода
- hi / si (hardware/ system interrupt) - аппаратные/ программные прерывания
- st (steal) - время когда гипервизор выполняет свои задачи и не может выделить ресурсы 

Load average - показывает среднее количество процессов и операций ввода-вывода в процессорной очереди