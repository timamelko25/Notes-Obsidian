RabbitMQ - брокер сообщений. Основная цель - принимать, хранить, отдавать сообщения.

Позволяет взаимодействовать различным программам при помощи протокола AMQP (Advanced Message Queuing Protocol). 
AMQP - открытый протокол для передачи сообщений между компонентами системы с низкой задержкой и высокой скоростью.

Основная идея - отдельные подсистемы (или независимые приложения) могут обмениваться произвольным образом сообщениями через AMQP-брокер, который осуществляет маршрутизацию, возможно гарантирует доставку, распределение потоков данных, подписку на нужные типы сообщений

Как устроен
На самом нижнем уровне определяется формат кодирования данных в бинарный вид для передачи по TCP-соединению, выше лежит формат передачи RPC-запросов между сервером и клиентом. Семантика работы с сообщениями создания очередей и тд описывается в XML-спецификации, которая задает RPC-интерфейс сервера и клиента. Описывается через XML-файлы версиями 0-8 и 0-10. Реализация сильно отличается, взаимно-обратной поддержки нет.

AMQP основные 3 понятия:
1. Сообщения (message) - единица передаваемых данных, основная часть (содержание) никак не интерпретируется сервером, к сообщению могут быть прикреплены структурированные заголовки.
2. Точка обмена (exchange) - место отправки сообщений. Точка обмена распределяет сообщения в одну или несколько очередей. В точке обмена сообщения не хранятся. 
	- Есть 3 типа точек обмена:
		- fanout - сообщение передается во все прикрепленные к ней очереди.
		- direct - сообщения передаются в очередь с именем, совпадающим с ключом маршрутизации (routing key) (ключ маршрутизации указывается при отправке сообщения)
		- topic - среднее между fanout и direct, сообщение передается в очереди, для которых совпадает маска на ключ маршрутизацию. Например: `app.notification.sms.*` — в очередь будут доставлены все сообщения, отправленные с ключами, начинающимися на `app.notification.sms`.
3. Очередь (queue) - место хранения сообщений, пока не будут забраны потребителем. Потребитель всегда забирает сообщения из одной или нескольких очередей.

Основные термины RabbitMQ:
1. Producer (продюсер) - программа, отправляющая сообщения.
2. Queue (очередь) - место хранения сообщений. Очередь не имеет ограничений на количество сообщений. Любое количество продюсеров может отправлять сообщения в одну очередь, также любое количество слушателей может получать сообщения из одной очереди.
3. Consumer (слушатель) - программа, принимающая сообщения. Обычно слушатель находится в состоянии ожидания сообщений.

Продюсер, брокер, слушатель могут быть развернуты на разных машинах.


!!! Пример на поставку в очередь и чтение из очереди.
простейший пример на 1 продюсер и 1 консьюмер

Создание очереди для распределения ресурсоемких задач между несколькими консьюмерами

Основная цель такой очереди - не начинать выполнение задачи сразу и не ждать пока оно завершится. Вместо этого задачи откладываются. Программа-обработчик, работающая в фоновом режиме, примет задачу на обработку, и через какое-то время она будет выполнена. При запуске нескольких обработчиков задачи будут распределены между ними.

Пример кода

![[Pasted image 20250330145742.png]]

По умолчанию RabbitMQ будет передавать каждое новое сообщение следующему слушателю. Таким образом, все слушатели получат одинаковое количество сообщений. Используемый способ распределения сообщений называется циклическим (алгоритм round-robin).

При аварийном завершении по умолчанию сообщение удаляется после доставки слушателю и задача не будет выполнена и сообщение будет утеряно. Для решения этой проблемы необходимо ввести подтверждение сообщений (ack). Подтверждение отправляется слушателем для информирования RabbitMQ о том что сообщение было обработано и RabbitMQ может его удалить. Если подтверждение не было получено, то сообщение будет передано следующему слушателю. Для обработки сообщений отсутствует тайм-аут, сообщение будет передано следующему только при закрытии соединения.

По умолчанию очереди создаются неустойчивыми и при завершении работы RabbitMQ все сообщения теряются. Можно объявить только новую очередь устойчивой, старые очереди изменить нельзя, будет вызвана ошибка. При пометки устойчивости все еще есть шанс что после кеширования сообщения оно не будет записано на диск. Для более высокой надежности необходимо использовать транзакции.

Для равномерности отправки сообщений (все четные задачи простые, нечетные сложные) можно использовать basic_qos. При использовании этого параметра RabbitMQ будет не отдавать подписчику единовременно более одного сообщения (слушатель не получит новое сообщение пока не обработает старое)