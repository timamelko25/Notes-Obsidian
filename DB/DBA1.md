Кластер баз данных - набор баз данных, управляемых экземпляром сервера. 

# Установка

```
tar xzf postgresql-16.0.tar.gz

cd postgresql-16.0.tar.gz

# for clean previous configuratins
make distclean

# custom flags
./configure --prefix=/home/user/pgsql16 --with-port=5555

# config only server
make

# config with all extentestions, docs
make world

make install

# for install with all
make install-world

# for extensions
cd contrib

make
make install
```

## Создание кластера

Кластер нельзя создать от root. Обычно владельцем кластера является пользователь `postgres`

`initdb` (-k --data-checksums - рекомендуется включить подсчет контрольных сумм, служит для обнаружения повреждения в данных)

PGDATA - переменная окружения для каталога кластера

```
mkdir /home/user/pgsql16/data

export PGDATA=/home/user/pgsql16/data

export PATH=/home/user/pgsql16/bin:$PATH

initdb -U postgres -k -D /home/user/pgsql16/data
```

- -U - указание суперпользователя СУБД
- -k - подсчет контрольных сумм
- -D - указание каталога для PGDATA (если переменная не установлена)

## Управление сервером

Общее управление с помощью утилиты `pg_ctl`

```
pg_ctl start -l /home/student/logfile

pg_ctl stop
```

## Подключение к кластеру

Подключение происходит через `psql`

```
psql -U postgres -p 5555
```

## Установка через пакетный менеджер

В Ubuntu создана обертка `pg_createcluster` над утилитой `initdb` (не включает -k). Для удаления кластера используется утилита `pg_dropcluster`.

Для дистрибутивов лучше использовать настроенный пакет

```
# посмтореть флаги при сборке конфигурации

sudo /usr/lib/postgresql/16/bin/pg_config --configure
```

В пакетном дистрибутиве для Ubuntu доступ к утилите `pg_ctl`
осуществляется не напрямую, а через специальную обертку
`pg_ctlcluster`.
Состояние кластеров `pg_lsclusters`

В каталоге `/usr/lib/postgresql/16/bin/` - лежат исполняемые файлы pg для работы с кластером

Например: включить контрольные суммы в кластере

```
sudo pg_ctlcluster 16 main stop

sudo /usr/lib/postgresql/16/bin/pg_checksums --check -D /var/lib/postgresql/16/main

sudo /usr/lib/postgresql/16/bin/pg_checksums --enable -D /var/lib/postgresql/16/main

sudo pg_ctlcluster 16 main start
```

# psql

## Назначение

Терминальный клиент для работы с PosgreSQL

Запуск

```
psql -d база -U пользователь -h узел(хост, UNIX-сокет) -p порт
```

Новое подключение
```
\c[connect] база пользователь узел порт
```

Информация о текущем информации
```
\conninfo
```

Пример многострочной команды
```
select schemaname, tablename, tableowner
from pg_tables
limit 5;
```

`\a` - переключение режима выравнивания
`\t` - переключение отображения строки заголовка и итоговой строки
`\pset filedsep ' '` - указание нового разделителя полей
`\x` - переключение расширенного формата (разворачивает вывод и указывает по записям)
`select ... \gx` - включение расширенного режима для конкретной команды
`\pset` - вывод всех настроек формата вывода
`\! pwd` - выполнеие shell команды из `psql`
`\setenv HELLO hi` - установка переменной окружения ОС 
`\getenv path PATH` - установку в переменной `psql` из переменной окружения ОС
`\set Test Hi` - установка значения в переменной `psql`
`\set` - просмотр всех установленных переменных
`\echo :Test :path` - вывести переданные переменные
`\unset` - сбросить переменную
`select now() as curr_time \gset` - запись результата запроса в переменную, запрос должен возвращать только 1 запись
`\o filename` - переключение режима: запись вывода команды в файл
`\g`
`\i` - выполнить файл как скрипт
`psql < filename` - выполнить скрипт из ОС
`psql -f filename`
`\gexec`

## Условные операторы

`\echo :{?working_dir}` - проверить установлено ли значение в переменную

```
\if :{?working_dir}
-- переменная определена
\else
	\set working_dir 'pwd' # команда посдстановки
\endif
```

`\d[escribe] pg_tables` - представление таблиц и представлений

## Настройка psql
При запуске `psql` выполняются 2 скрипта (при их наличии)
- общий системный скрипт `psqlrc` - расположение системного скрипта `pg_config --sysconfdir`
- пользовательский файл `.psqlrc` - должен располагаться в домашнем каталоге

Пример: записать в переменную макрос (можно добавить в `.psqlrc` и всегда можно запустить :top5)

```
\set top5 'SELECT tablename, pg_total_relation_size(schemaname||''.''||tablename) AS bytes FROM pg_tables ORDER BY bytes DESC LIMIT 5;'

:top5
```

Приглашение (PROMT) - переменная для вывода информации в подключении

Добавить информацию о роли 
```
echo "\set PROMPT1 '%n@%/%R%x%# '" >> ~/.psqlrc

echo "\set PROMPT2 '%n@%/%R%x%# '" >> ~/.psqlrc
```

## Конфигурирование сервера

Основной конфигурационный файл `postgresql.conf`. Считывается при старте сервера, можно подключить дополнительные файлы, по умолчанию находится в PGDATA. `-c` - можно указать другое местоположение файла

При внесении изменений необходимо перечитать файл или перезапустив сервер

```
# ОС
pg_ctl reload

# psql
select pg_reload_conf()
```

Местоположение конфигурационного файла

```
show config_file;
```

- include_dir — каталог с дополнительными файлами конфигурации;
- include — включает дополнительный файл конфигурации;
- include_if_exists — включает дополнительный файл конфигурации, если он существует.

Просмотр настроек
```
SELECT sourceline, name, setting, applied, error FROM pg_file_settings;
```

Столбец applied показывает, будет ли
заданное значение применено при перечитывании. В частности, в столбце будет false, если:
- изменение требует рестарта сервера;
- существует строка с тем же параметром, которая будет прочитана позже;
- в одной из строк, где задается параметр, есть ошибка.

Представление также показывает имя файла конфигурации и номер строки, что удобно для поиска ошибок.

Все параметры читаются сверху вниз и если указать несколько значений для 1 параметра, то будет применен последний.

## Представление pg_settings 

`work_mem` - определяет объем памяти для таких операций, как сортировка или хеш-соединение. Если памяти не будет хватать, то часть данных будет записана на диск и читаться оттуда.

```
SELECT name, unit, setting, boot_val, reset_val,
source, sourcefile, sourceline, pending_restart, context
FROM pg_settings
WHERE name = 'work_mem' \gx
```

- name, unit — название и единица измерения параметра;
- setting — текущее значение;
- boot_val — значение по умолчанию;
- reset_val — начальное значение для сеансов;
- source — источник текущего значения параметра;
- sourcefile, sourceline — файл конфигурации и номер строки, если текущее значение было задано в файле;
- pending_restart — true, если значение изменено в файле конфигурации, но для применения требуется перезапуск
сервера.

Столбец context определяет действия для применения параметра:
- internal - изменить нельзя, задано при установке
- postmaster - требуется перезапуск сервера
- sighup - требуется перечитать файлы конфигурации
- superuser - суперпользователь может изменить для своего сеанса
- user - любой пользователь можем изменить для своего сеанса

postgresql.auto.conf - последний считываемый файл для конфигураций. Изменяется только через `ALTER SYSTEM`. 

```
alter system set work_mem to '16MB';
```

Для получения текущих настроек 

```
SHOW work_mem;

select current_setting('work_mem');

\dconfig work_mem
```

Для изменения параметров в текущей сессии. Можно установить срок действия: до конца сеанса (по умолчанию) или до конца транзакции (SET LOCAL). 

```
SET wirk_mem to '24MB';

select set_config('work_mem', '32MB', false);
```

Можно создать пользовательские параметры во время сеанса. В имени обязательно должна быть точка, чтобы отличить от стандартных параметров.

```
SELECT CASE
WHEN current_setting('myapp.currency_code', true) IS NULL
THEN set_config('myapp.currency_code', 'RUB', false)
ELSE
current_setting('myapp.currency_code')
END;
```

# Архитектура

Для связи клиента и сервера используется один протокол взаимодействия. Обычно клиент использует драйвер, реализующий протокол и предоставляющий набор функций для использования про грамме. Внутри драйвер обычно использует стандартную реализацию протокола (библиотека libpq)

Протокол позволяет клиенту подключаться к одной из баз данных кластера. При этом сервер выполняет аутентификацию

## Транзакции

Транзакция - последовательность операций, которая сохраняет согласованность данных при условии, что операции выполняются полностью и без помех со стороны других транзакций. Транзакция должна поддерживать [[ACID]].

По умолчанию переменная `AUTOCOMMIT -> on` создает обертку транзакции  вокруг каждой операции и сразу применяет `COMMIT` для применения изменений.

Можно создать точку сохранения в транзакции, к которой можно откатиться 

```
begin;

savepoint sp;

rollback to sp;
```

## Выполнение запроса

1. Разбор - выполняется синтаксический (буквы в слова, слова в команды) и семантический (есть ли объекты в бд, уровни доступа) разборы. Мета информация (данные бд, уровни доступа...) называется системным каталогом, хранится в специальных таблицах
2. Переписывание (трансформация) - вместо имени представления представления подставляется текст запроса. Можно указать свои трансформации, для чего есть механизм правил. Можно использовать другие различные правила к запросам или использовать триггеры. 
3. Планировщик - разобранный и представленный запрос передается планировщику, который разрабатывает план выполнения. Для качественно плана запроса планировщику нужна информация и размере таблиц и о распределении данных в них - статистика.
4. Выполнение - получение данных

## Подготовка операторов

Операторы - ключевые слова для выполнения операций (select, insert, update...)

Каждый запрос проходит все шаги для получения данных. Но если 1 и тот же запрос (с точностью до параметров) выполняется много раз, можно не разбирать его заново. 

Существует расширенный режим, который позволяет детально управлять выполнением операторов. Одна из возможностей - подготовить запрос - заранее выполнить разбор и переписывание и запомнить дерево разбора.

При выполнении запроса выполняется привязка конкретных значений параметров.

Оператор подготавливается командой `PREPARE` (расширение в PostgreSQL, отсутствует в стандарте). Параметры передаются по номерам

```
PREPARE q(integer) AS
SELECT * FROM t WHERE id = $1;

EXECUTE q(1);
```

Просмотр всех подготовленных операторов текущего сеанса
```
SELECT * FROM pg_prepared_statements \gx
```

generic_plans - план без учета параметров 
custom_plans - количество выполняемых запросов, которые учитывают входящие параметры

## Курсоры

Расширенный режим протокола, который позволяет получать не все результаты сразу, а построчно по мере необходимости. Курсор необходимо объявить и открыть для начало работы. Открытый курсор представлен на сервере так называемым порталом

Курсоры автоматически закрываются по окончании транзакции, можно не закрывать явно (исключение - курсоры открытые с указанием `WITH HOLD`. 

```
BEGIN;

DECLARE c CURSOR FOR
SELECT * FROM t ORDER BY id;

FETCH c;

FETCH 2 c;

CLOSE c;

COMMIT;

<------->
# открытие курсора
DECLARE user_cursor CURSOR FOR
SELECT id, name FROM users;

OPEN user_cursor;
```

## Процессы и память

![[Pasted image 20250630003241.png]]

При старте сервера запускается процесс - postmaster (postpostgres). Он запускает все остальные процессы (с помощью системного вызова fork в Unix) и следит за ними - если какой-то процесс завершиться аварийно, postmaster перезапустит его (или перезапустит весь сервер, если сочтет, что процесс мог повредить общие данные)

Работу сервера обеспечивает ряд фоновых служебных процессов

Для обмена информацией между процесса выделяется общая память. Кроме общей памяти каждый процесс имеет локальную память. 

Postmaster слушает входящие соединения. Для каждого вновь подключающегося клиента postmaster порождает обслуживающий процесс (backend) и дальше клиент общается с этим процессом. Обслуживающий процесс, в то числе производит аутентификацию.

Место необходимое для выполнения запроса (разобранные запросы и их планы, состояние курсоров, кеш системного каталога, место для сортировки...) выделяется в локальной памяти обслуживающего процесса. 

Отсутствует глобальный кеш подготовленных операторов, каждый сеанс кеширует самостоятельно. 

## Множественные подключения

![[Pasted image 20250630233306.png]]

В случае множественный подключениях каждый процесс обращается к общей памяти и таблицам, чтобы не блокировать данные на каждое подключение используется другие технологии.

Для объектов в общей памяти используются короткоживущие блокировки. Для таблиц, чтобы удерживать до конца транзакции (то есть потенциально в течение длительного времени), используется механизм многоверсионности (MVCC, multiversion concurrency control) и изоляцию на основе снимков данных: одни и те же данные могут одновременно существовать в разных версиях, а каждый процесс видит собственную картину данных. Это позволяет блокировать только те процессы, которые пытаются изменить данные, уже измененные, но еще не зафиксированные другими процессами. Многоверсионность - основой механизм который обеспечивает 3 свойства транзакций (атомарность, согласованность, изоляция)

## Пул соединений

![[Pasted image 20250630234326.png]]

Если клиентов слишком много или соединения устанавливаются и разрываются слишком часто, то можно использовать пул соединений. Множество клиентов подключается к пулу и сам пул держит несколько активных соединений к PostgreSQL, которые обрабатывают данные. 

При таком режиме работы несколько клиентов разделяют 1 обслуживающий процесс, который в своей локальной памяти хранит определенное состояние.

Одна из возможностей pgBouncer - временная приостановка обслуживания клиентов без разрыва соединений.

## Хранение данных

![[Pasted image 20250630234458.png]]

Логически файлы разделены на страницы (иногда блок). Обычно имеет размер 8 Кб, но можно изменить (16 или 32) при сборке сервера. 

Каждая страница имеет внутреннюю разметку. Страница содержит заголовок и полезные данные, между ними может находиться свободное пространство, если страница занята не полностью.

Для чтения страницы обычно используется кешировние с диска в буферный кеш оперативной памяти, для экономии обращения чтения страницы.

![[Pasted image 20250630234931.png]]

Буферный кеш располагается в общей памяти, чтобы все процессы имели к нему доступ. При сбое содержимое оперативной памяти пропадает, при этом измененные, но еще не записанные на диск данные теряются. Для избежания этой проблемы используется специальный журнал WAL (Write-Ahead Logging - журнал предзаписи), позволяющий выполнить повторно потерянные операции и восстановить данные  в согласованном состоянии. 