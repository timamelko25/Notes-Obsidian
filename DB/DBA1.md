Кластер баз данных - набор баз данных, управляемых экземпляром сервера. 

# Установка

```
tar xzf postgresql-16.0.tar.gz

cd postgresql-16.0.tar.gz

# for clean previous configuratins
make distclean

# custom flags
./configure --prefix=/home/user/pgsql16 --with-port=5555

# config only server
make

# config with all extentestions, docs
make world

make install

# for install with all
make install-world

# for extensions
cd contrib

make
make install
```

## Создание кластера

Кластер нельзя создать от root. Обычно владельцем кластера является пользователь `postgres`

`initdb` (-k --data-checksums - рекомендуется включить подсчет контрольных сумм, служит для обнаружения повреждения в данных)

PGDATA - переменная окружения для каталога кластера

```
mkdir /home/user/pgsql16/data

export PGDATA=/home/user/pgsql16/data

export PATH=/home/user/pgsql16/bin:$PATH

initdb -U postgres -k -D /home/user/pgsql16/data
```

- -U - указание суперпользователя СУБД
- -k - подсчет контрольных сумм
- -D - указание каталога для PGDATA (если переменная не установлена)

## Управление сервером

Общее управление с помощью утилиты `pg_ctl`

```
pg_ctl start -l /home/student/logfile

pg_ctl stop
```

## Подключение к кластеру

Подключение происходит через `psql`

```
psql -U postgres -p 5555
```

## Установка через пакетный менеджер

В Ubuntu создана обертка `pg_createcluster` над утилитой `initdb` (не включает -k). Для удаления кластера используется утилита `pg_dropcluster`.

Для дистрибутивов лучше использовать настроенный пакет

```
# посмтореть флаги при сборке конфигурации

sudo /usr/lib/postgresql/16/bin/pg_config --configure
```

В пакетном дистрибутиве для Ubuntu доступ к утилите `pg_ctl`
осуществляется не напрямую, а через специальную обертку
`pg_ctlcluster`.
Состояние кластеров `pg_lsclusters`

В каталоге `/usr/lib/postgresql/16/bin/` - лежат исполняемые файлы pg для работы с кластером

Например: включить контрольные суммы в кластере

```
sudo pg_ctlcluster 16 main stop

sudo /usr/lib/postgresql/16/bin/pg_checksums --check -D /var/lib/postgresql/16/main

sudo /usr/lib/postgresql/16/bin/pg_checksums --enable -D /var/lib/postgresql/16/main

sudo pg_ctlcluster 16 main start
```

# psql

## Назначение

Терминальный клиент для работы с PosgreSQL

Запуск

```
psql -d база -U пользователь -h узел(хост, UNIX-сокет) -p порт
```

Новое подключение
```
\c[connect] база пользователь узел порт
```

Информация о текущем информации
```
\conninfo
```

Пример многострочной команды
```
select schemaname, tablename, tableowner
from pg_tables
limit 5;
```

`\a` - переключение режима выравнивания
`\t` - переключение отображения строки заголовка и итоговой строки
`\pset filedsep ' '` - указание нового разделителя полей
`\x` - переключение расширенного формата (разворачивает вывод и указывает по записям)
`select ... \gx` - включение расширенного режима для конкретной команды
`\pset` - вывод всех настроек формата вывода
`\! pwd` - выполнеие shell команды из `psql`
`\setenv HELLO hi` - установка переменной окружения ОС 
`\getenv path PATH` - установку в переменной `psql` из переменной окружения ОС
`\set Test Hi` - установка значения в переменной `psql`
`\set` - просмотр всех установленных переменных
`\echo :Test :path` - вывести переданные переменные
`\unset` - сбросить переменную
`select now() as curr_time \gset` - запись результата запроса в переменную, запрос должен возвращать только 1 запись
`\o filename` - переключение режима: запись вывода команды в файл
`\g`
`\i` - выполнить файл как скрипт
`psql < filename` - выполнить скрипт из ОС
`psql -f filename`
`\gexec`

## Условные операторы

`\echo :{?working_dir}` - проверить установлено ли значение в переменную

```
\if :{?working_dir}
-- переменная определена
\else
	\set working_dir 'pwd' # команда посдстановки
\endif
```

`\d[escribe] pg_tables` - представление таблиц и представлений

## Настройка psql
При запуске `psql` выполняются 2 скрипта (при их наличии)
- общий системный скрипт `psqlrc` - расположение системного скрипта `pg_config --sysconfdir`
- пользовательский файл `.psqlrc` - должен располагаться в домашнем каталоге

Пример: записать в переменную макрос (можно добавить в `.psqlrc` и всегда можно запустить :top5)

```
\set top5 'SELECT tablename, pg_total_relation_size(schemaname||''.''||tablename) AS bytes FROM pg_tables ORDER BY bytes DESC LIMIT 5;'

:top5
```

Приглашение (PROMT) - переменная для вывода информации в подключении

Добавить информацию о роли 
```
echo "\set PROMPT1 '%n@%/%R%x%# '" >> ~/.psqlrc

echo "\set PROMPT2 '%n@%/%R%x%# '" >> ~/.psqlrc
```

## Конфигурирование сервера

Основной конфигурационный файл `postgresql.conf`. Считывается при старте сервера, можно подключить дополнительные файлы, по умолчанию находится в PGDATA. `-c` - можно указать другое местоположение файла

При внесении изменений необходимо перечитать файл или перезапустив сервер

```
# ОС
pg_ctl reload

# psql
select pg_reload_conf()
```

Местоположение конфигурационного файла

```
show config_file;
```

- include_dir — каталог с дополнительными файлами конфигурации;
- include — включает дополнительный файл конфигурации;
- include_if_exists — включает дополнительный файл конфигурации, если он существует.

Просмотр настроек
```
SELECT sourceline, name, setting, applied, error FROM pg_file_settings;
```

Столбец applied показывает, будет ли
заданное значение применено при перечитывании. В частности, в столбце будет false, если:
- изменение требует рестарта сервера;
- существует строка с тем же параметром, которая будет прочитана позже;
- в одной из строк, где задается параметр, есть ошибка.

Представление также показывает имя файла конфигурации и номер строки, что удобно для поиска ошибок.

Все параметры читаются сверху вниз и если указать несколько значений для 1 параметра, то будет применен последний.

## Представление pg_settings 

`work_mem` - определяет объем памяти для таких операций, как сортировка или хеш-соединение. Если памяти не будет хватать, то часть данных будет записана на диск и читаться оттуда.

```
SELECT name, unit, setting, boot_val, reset_val,
source, sourcefile, sourceline, pending_restart, context
FROM pg_settings
WHERE name = 'work_mem' \gx
```

- name, unit — название и единица измерения параметра;
- setting — текущее значение;
- boot_val — значение по умолчанию;
- reset_val — начальное значение для сеансов;
- source — источник текущего значения параметра;
- sourcefile, sourceline — файл конфигурации и номер строки, если текущее значение было задано в файле;
- pending_restart — true, если значение изменено в файле конфигурации, но для применения требуется перезапуск
сервера.

Столбец context определяет действия для применения параметра:
- internal - изменить нельзя, задано при установке
- postmaster - требуется перезапуск сервера
- sighup - требуется перечитать файлы конфигурации
- superuser - суперпользователь может изменить для своего сеанса
- user - любой пользователь можем изменить для своего сеанса

postgresql.auto.conf - последний считываемый файл для конфигураций. Изменяется только через `ALTER SYSTEM`. 

```
alter system set work_mem to '16MB';
```

Для получения текущих настроек 

```
SHOW work_mem;

select current_setting('work_mem');

\dconfig work_mem
```

Для изменения параметров в текущей сессии. Можно установить срок действия: до конца сеанса (по умолчанию) или до конца транзакции (SET LOCAL). 

```
SET wirk_mem to '24MB';

select set_config('work_mem', '32MB', false);
```

Можно создать пользовательские параметры во время сеанса. В имени обязательно должна быть точка, чтобы отличить от стандартных параметров.

```
SELECT CASE
WHEN current_setting('myapp.currency_code', true) IS NULL
THEN set_config('myapp.currency_code', 'RUB', false)
ELSE
current_setting('myapp.currency_code')
END;
```

# Архитектура

Для связи клиента и сервера используется один протокол взаимодействия. Обычно клиент использует драйвер, реализующий протокол и предоставляющий набор функций для использования про грамме. Внутри драйвер обычно использует стандартную реализацию протокола (библиотека libpq)

Протокол позволяет клиенту подключаться к одной из баз данных кластера. При этом сервер выполняет аутентификацию

## Транзакции

Транзакция - последовательность операций, которая сохраняет согласованность данных при условии, что операции выполняются полностью и без помех со стороны других транзакций. Транзакция должна поддерживать [[ACID]].

По умолчанию переменная `AUTOCOMMIT -> on` создает обертку транзакции  вокруг каждой операции и сразу применяет `COMMIT` для применения изменений.

Можно создать точку сохранения в транзакции, к которой можно откатиться 

```
begin;

savepoint sp;

rollback to sp;
```

## Выполнение запроса

1. Разбор - выполняется синтаксический (буквы в слова, слова в команды) и семантический (есть ли объекты в бд, уровни доступа) разборы. Мета информация (данные бд, уровни доступа...) называется системным каталогом, хранится в специальных таблицах
2. Переписывание (трансформация) - вместо имени представления представления подставляется текст запроса. Можно указать свои трансформации, для чего есть механизм правил. Можно использовать другие различные правила к запросам или использовать триггеры. 
3. Планировщик - разобранный и представленный запрос передается планировщику, который разрабатывает план выполнения. Для качественно плана запроса планировщику нужна информация и размере таблиц и о распределении данных в них - статистика.
4. Выполнение - получение данных

## Подготовка операторов

Операторы - ключевые слова для выполнения операций (select, insert, update...)

Каждый запрос проходит все шаги для получения данных. Но если 1 и тот же запрос (с точностью до параметров) выполняется много раз, можно не разбирать его заново. 

Существует расширенный режим, который позволяет детально управлять выполнением операторов. Одна из возможностей - подготовить запрос - заранее выполнить разбор и переписывание и запомнить дерево разбора.

При выполнении запроса выполняется привязка конкретных значений параметров.

Оператор подготавливается командой `PREPARE` (расширение в PostgreSQL, отсутствует в стандарте). Параметры передаются по номерам

```
PREPARE q(integer) AS
SELECT * FROM t WHERE id = $1;

EXECUTE q(1);
```

Просмотр всех подготовленных операторов текущего сеанса
```
SELECT * FROM pg_prepared_statements \gx
```

generic_plans - план без учета параметров 
custom_plans - количество выполняемых запросов, которые учитывают входящие параметры

## Курсоры

Расширенный режим протокола, который позволяет получать не все результаты сразу, а построчно по мере необходимости. Курсор необходимо объявить и открыть для начало работы. Открытый курсор представлен на сервере так называемым порталом

Курсоры автоматически закрываются по окончании транзакции, можно не закрывать явно (исключение - курсоры открытые с указанием `WITH HOLD`. 

```
BEGIN;

DECLARE c CURSOR FOR
SELECT * FROM t ORDER BY id;

FETCH c;

FETCH 2 c;

CLOSE c;

COMMIT;

<------->
# открытие курсора
DECLARE user_cursor CURSOR FOR
SELECT id, name FROM users;

OPEN user_cursor;
```

## Процессы и память

![[Pasted image 20250630003241.png]]

При старте сервера запускается процесс - postmaster (postpostgres). Он запускает все остальные процессы (с помощью системного вызова fork в Unix) и следит за ними - если какой-то процесс завершиться аварийно, postmaster перезапустит его (или перезапустит весь сервер, если сочтет, что процесс мог повредить общие данные)

Работу сервера обеспечивает ряд фоновых служебных процессов

Для обмена информацией между процесса выделяется общая память. Кроме общей памяти каждый процесс имеет локальную память. 

Postmaster слушает входящие соединения. Для каждого вновь подключающегося клиента postmaster порождает обслуживающий процесс (backend) и дальше клиент общается с этим процессом. Обслуживающий процесс, в то числе производит аутентификацию.

Место необходимое для выполнения запроса (разобранные запросы и их планы, состояние курсоров, кеш системного каталога, место для сортировки...) выделяется в локальной памяти обслуживающего процесса. 

Отсутствует глобальный кеш подготовленных операторов, каждый сеанс кеширует самостоятельно. 

## Множественные подключения

![[Pasted image 20250630233306.png]]

В случае множественный подключениях каждый процесс обращается к общей памяти и таблицам, чтобы не блокировать данные на каждое подключение используется другие технологии.

Для объектов в общей памяти используются короткоживущие блокировки. Для таблиц, чтобы удерживать до конца транзакции (то есть потенциально в течение длительного времени), используется механизм многоверсионности (MVCC, multiversion concurrency control) и изоляцию на основе снимков данных: одни и те же данные могут одновременно существовать в разных версиях, а каждый процесс видит собственную картину данных. Это позволяет блокировать только те процессы, которые пытаются изменить данные, уже измененные, но еще не зафиксированные другими процессами. Многоверсионность - основой механизм который обеспечивает 3 свойства транзакций (атомарность, согласованность, изоляция)

## Пул соединений

![[Pasted image 20250630234326.png]]

Если клиентов слишком много или соединения устанавливаются и разрываются слишком часто, то можно использовать пул соединений. Множество клиентов подключается к пулу и сам пул держит несколько активных соединений к PostgreSQL, которые обрабатывают данные. 

При таком режиме работы несколько клиентов разделяют 1 обслуживающий процесс, который в своей локальной памяти хранит определенное состояние.

Одна из возможностей pgBouncer - временная приостановка обслуживания клиентов без разрыва соединений.

## Хранение данных

![[Pasted image 20250630234458.png]]

Логически файлы разделены на страницы (иногда блок). Обычно имеет размер 8 Кб, но можно изменить (16 или 32) при сборке сервера. 

Каждая страница имеет внутреннюю разметку. Страница содержит заголовок и полезные данные, между ними может находиться свободное пространство, если страница занята не полностью.

Для чтения страницы обычно используется кешировние с диска в буферный кеш оперативной памяти, для экономии обращения чтения страницы.

![[Pasted image 20250630234931.png]]

Буферный кеш располагается в общей памяти, чтобы все процессы имели к нему доступ. При сбое содержимое оперативной памяти пропадает, при этом измененные, но еще не записанные на диск данные теряются. Для избежания этой проблемы используется специальный журнал WAL (Write-Ahead Logging - журнал предзаписи), позволяющий выполнить повторно потерянные операции и восстановить данные  в согласованном состоянии. 

## Многоверсионность

![[Pasted image 20250706155102.png]]

При одновременной работе над одной строкой несколькими сеансами обработка одновременно двумя транзакциями возникает сложность как они работают. 

Если обе читающие, то они читают последовательно. Если обе пишущие, то они выполняются последовательно. 

Если пишущая и читающая транзакции. 
1. Транзакции могут блокировать друг друга, но страдает производительность. Если читающая сразу прочитает изменения пишущей, то может быть грязное чтение. 
2. Многоверсионность - хранение нескольких версий одной и той же строки. Пишущая транзакция работает со своей версией, читающая видит свою. Для отличия версий используются всегда возрастающие номера транзакций. Когда строка создается, она помечается номером транзакции, выполнивший команду INSERT. Когда удаляется - версия помечается номером транзакции выполнившей  DELETE (но физически не удаляется). UPDATE состоит из двух операций DELETE и INSERT. 

![[Pasted image 20250706155938.png]]

В PostgreSQL применяется изоляция на основе снимков данных.

Транзакция, обращаясь ко таблице, должна видеть только одну из имеющихся версий каждой строки (или не видеть ни одной). Для этого транзакция работает со снимков данных, созданным в определенный момент времени. В снимке видны самые последние версии уже зафиксированных данных, а еще не зафиксированные данные не видны. 

Снимок - не физическая копия данных, а числа:
- номер последней зафиксированной транзакции на момент создания снимка
- список активных транзакций на этот момент

Список нужен для того, чтобы исключить из снимка изменения тех транзакций, которые начались до создания снимка, но еще не были зафиксированы.

## Уровни изоляции

- Read Uncommitted
не поддерживается PostgreSQL: работает как Read Committed
- Read Committed — используется по умолчанию
снимок строится на момент начала оператора
одинаковые запросы могут каждый раз получать разные данные
- Repeatable Read
снимок строится на момент начала первого оператора транзакции
транзакция может завершиться ошибкой сериализации
- Serializable
полная изоляция, но дополнительные накладные расходы
транзакция может завершиться ошибкой сериализации

```
begin;

select pg_current_xact_id(); # показать номенр текущей транзакции

select *, xmin,xmax from t1; # вывести скрытые столбцы номера транзакций, ограничивающих видисомть версии строки: xmin - номер транзакции с которой начали (создала версию), xmax - номер транзакции, которая сделала данные неактульными (0 - версия актуальна)
```

![[Pasted image 20250706162710.png]]

Механизм многоверсионности позволяет эффективно реализовать изоляцию на основе снимков, но в результате в табличных страницах накапливаются старые (мертвые) версии строк 

Для каждой базы данных существует такой номер xid, что все исторические версии, удаленные транзакции с меньшими номерами, уже не видны ни в одном снимке. Этот номер называется горизонтом очистки. 

Очистка производится группой специальных фоновых процессов, можно выполнить вручную командой `VACUUM`. 

Многоверсионность позволяет обойтись минимумом блокировок, тем самым увеличивая производительность системы. На уровне строк применяются снимки.

- Блокировки строк
чтение никогда не блокирует строки
изменение строк блокирует их для изменений, но не для чтений
- Блокировки таблиц
запрещают изменение или удаление таблицы, пока с ней идет работа
запрещают чтение таблицы при перестроении или перемещении
и т. п.
- Время жизни блокировок
устанавливаются по мере необходимости или вручную
снимаются автоматически при завершении транзакции или при откате к точке сохранения

Для работы многоверсионности серверу надо понимать в каком статусе находятся транзакции. Транзакция может быть активна или завершена. Завершится транзакция может либо фиксацией, либо обрывом. Таким образом, для представления состояния каждой транзакции требуется два бита.

Статусы транзакций (commit log, clog) хранятся в служебных файлах каталога PGDATA/pg_xact, работа с ними происходит в общей памяти сервера, чтобы не обращаться постоянно к диску. 

При любом завершении транзакции необходимо установить соответствующие биты статуса. И фиксация и обрыв транзакций происходят одинаково быстро. 

Если прерванная транзакция успела создать новые версии строк, эти версии не уничтожаются (не происходит физического отката данных). Благодаря информации о статусах другие транзакции увидят, что транзакция, создавшая или удалившая версии строк, была прервана и не станут принимать во внимание сделанные ей изменения. 

## Очистка

Периодические задачи:
- Очистка страниц из исторических данных, которые образуются из-за многоверсионности
Из таблиц вычищаются мертвые версии строк, из индексов вычищаются записи, ссылающие на мертвые версии.
- Обновление карты видимости
Отмечает страницы, на которых все актуальные версии строк видны во всех снимках, используется для оптимизации процесса очистки и ускорения индексного доступа, существует только для таблиц
- Обновление карты свободного пространства
Отмечает свободное пространство в страницах после очистки, используется при вставки новых версий строк, существует для таблиц и индексов. Имеет древовидную структуру
- Обновление статистики
Используется оптимизатором запросов, вычисляется на основе случайной выборки
- Заморозка
Предотвращение последствий переполнения 32-битного счетчика транзакций. Счетчик транзакций закольцован. Если счетчик перейдет через 0, то упорядоченность транзакций может нарушиться. Достаточно старые версии строк помечаются как "замороженные". Такой признак говорит, что версия появилась так давно, что номер создавшей ее транзакции больше не имеет значения и можно использовать его повторно. Замороженные версии строк видны во всех снимках всех транзакций. Чтобы при заморозке не просматривать лишние страницы, в карту видимости добавлен бит, отмечающий страницы, на которых все версии строк уже заморожены. 

## Автоматическая очистка

![[Pasted image 20250706172609.png]]


Фоновый процесс автоочистки берет на себя все периодические задачи. Он динамически реагирует на частоту обновления таблиц: чем активней изменения, тем чаще таблицы будет обрабатываться. 

В системе постоянно присутствует процесс autovacuum launcher, который планирует работу очистки и запускает необходимое число рабочих процессов autovacuum worker, работающих параллельно. 

Автоматическая очистка перестает работать при отключении любого из двух параметров autovacuum или track_counts

```
vacuum [table, ...] # очистка отдельных таблиц

vacuum # очистка всей бд

vacuumdb # обертка для использования в ОС

analyze

vacuumdb --analyze-only

vacuum analyze

vacuumdb --analyze
```

Проблема разрастания

- Очистка не уменьшает размер таблиц и индексов
освобожденное место используется для новых данных, не возвращается ОС
- Причины разрастания
	- неправильная настройка автоочистки
	- массовое изменение данных
	- долгие транзакции
- Негативное влияние
	- перерасход места на диске
	- замедление последовательного просмотра таблиц
	- уменьшение эффективности индексного доступа

В случае индексов (сбалансированные деревья) если на странице не хватает места для размещения индексной записи, страница расщепляется на две. Получившиеся страницы уже не объединяются, даже если из них будут удалены все индексные записи.

Оценка разрастания таблиц и индексов

```
CREATE EXTENSION pgstattuple;

# проверить состояние таблицы
SELECT * FROM pgstattuple('bloat') \gx

-[ RECORD 1 ]------+--------
table_len | 4874240
tuple_count | 100000
tuple_len | 4000000
tuple_percent | 82.06
dead_tuple_count | 0
dead_tuple_len | 0
dead_tuple_percent | 0
free_space | 457324
free_percent | 9.38

# состояние индекса
SELECT * FROM pgstatindex('bloat_d_idx') \gx

-[ RECORD 1 ]------+-------
version | 4
tree_level | 1
index_size | 778240
root_block_no | 3
internal_pages | 1
leaf_pages | 85
empty_pages | 0
deleted_pages | 8
avg_leaf_density | 89.17
leaf_fragmentation | 0
```

tuple_percent — доля полезной информации (не 100% из-за накладных расходов
leaf_pages — количество листовых страниц индекса;
avg_leaf_density — заполненность листовых страниц;
leaf_fragmentation — характеристика физической упорядоченности листовых страниц (0 — порядок, 100 —
беспорядок).

Перестроение объектов. Для того чтобы уменьшить физический размер разросшихся таблиц и индексов, требуется полная очистка
- Полная очистка - `vacuum full (OC: vacuumdb --full)`
	- полностью перестраивает содержимое таблиц и индексов
	- полностью блокирует работу с таблицей
- Перестроение индексов - `reidnex`
	- перестраивает индексы
	- полностью блокирует работу с индексов и блокирует изменение таблицы
- Неблокирующее перестроение индексов - `reidnex .. concurrently`
	- перестраивает индексы, не блокируя изменение таблицы
	- выполняется дольше и может завершиться неудачно
	- не транзакционно
	- не работает для системных индексов
	- не работает для индексов, связанных с ограничениями-исключениями

## Буферный кеш

![[Pasted image 20250706214623.png]]

Буферный кеш используется для сглаживания скорости и работы оперативной памяти и дисков. Он состоит из массива буферов, которые содержат страницы данных и дополнительную информацию (имя файла и положение страницы внутри файла).

Любая работа со страницами данных проходит через буферный кеш. Какой-либо процесс сначала ищет страницу в кеше. Если страницы нет, он обращается в ОС для чтения страницы и помещения ее в буферный кеш. 

Если процесс изменил данные в странице, соответствующий буфер становится грязным. Измененная страница подлежит записи на диск, но запись происходит асинхронно и может откладываться. 

Буферный кеш, как и другие структуры общей памяти, защищен блокировками для управления одновременным доступом. 

Для освобождения места в буферном кеше используется вытеснение страниц. Алгоритм вытеснения выбирает в кеше страницу, которая в последнее время использовалась реже других. Если выбранный буфер оказался грязным, страница записывается на диск, чтобы не потерять сделанные в ней изменения. Затем в освободившийся буфер читается новая страница. Такой алгоритм называется LRU (Least Recently Used). Он сохраняет в кеше данные, с которыми происходит активная работа.

```
show shared_buffers; # показать размер буферного кеша


student@arch_wal_overview=# explain (analyze, buffers, costs off, timing off) 
select * from t;
                 QUERY PLAN                 
--------------------------------------------
 Seq Scan on t (actual rows=300000 loops=1)
   Buffers: shared read=1229
 Planning:
   Buffers: shared hit=15 read=5
 Planning Time: 0.834 ms
 Execution Time: 58.874 ms
(6 rows)

student@arch_wal_overview=# explain (analyze, buffers, costs off, timing off) 
select * from t;
                 QUERY PLAN                 
--------------------------------------------
 Seq Scan on t (actual rows=300000 loops=1)
   Buffers: shared hit=1229
 Planning Time: 0.088 ms
 Execution Time: 50.883 ms
(4 rows)
```

Buffers: shared - показывается использование буферного кеша
- read - количество буферов, в которые пришлось прочитать страницы с диска
- hit - количество буферов, в которые нашлись нужные для запроса страницы

## Журнал предзаписи (WAL)

Буферный кеш хранится в оперативной памяти и в случае сбоя в СУБД содержимое буферного кеша потеряется. Если сбой произойдет в операционной системе или на аппаратном уровне, то пропадет содержимое и буферов ОС.

Для обеспечения надежности PostgreSQL использует журналирование. При выполнении любой операции формируется запись, содержащая минимально необходимую информацию для того, чтобы операцию можно было выполнить повторно. Такая запись должна попасть на диск раньше, чем будут записаны изменяемые операцией данные (поэтому и журнал предзаписи write-ahead log)

Файлы журнала находятся в каталоге  `PGDATA/pg_wal`. По умолчанию файлы имеют размер 16 МБайт, другой размер можно задать при инициализации кластера баз данных.

Журнал защищает все объекты, работа с которыми ведется в оперативной памяти: таблицы, индексы и другие объекты, статус транзакций. В журнал не попадают данные о временных таблицах и о нежурналируемых таблицах. 

Сам журнал представляется в виде потока записей. Каждая запись имеет номер (адрес), называемый LSN (Log Sequence Number). Это 64-разрядное число - смещение записи в байтах относительно журнал

```
select pg_current_wal_lsn(); # показать текущую позицию журнала

SELECT '0/237BD40'::pg_lsn - '0/2378D28'::pg_lsn AS bytes; # посмотреть в байтах размер изменения

SELECT * FROM pg_ls_waldir() ORDER BY name LIMIT 10; # посмотреть файлы журанала
```

Позиция журнала показывается как два 32-разрядных числа через `/`. 

![[Pasted image 20250706225136.png]]

После запуска после сбоя сервер PostgreSQL входит в режим восстановления. Информация на диске в это время несогласованна: изменения "горячих" страниц пропали, поскольку эти страницы все еще находились в кеше, а более поздние изменения уже были сброшены на диск.

Чтобы восстановить согласованность PostgreSQL читает WAL и последовательно проигрывает каждую его запись, если соответствующие изменение не попало на диск. Таким образом восстанавливается работа всех транзакций. Транзакции, запись о фиксации которых не успела попасть в журнал считаются оборванными. 

Для избежания гигантских размеров журнала СУБД периодически выполняет контрольную точку: принудительно сбрасывает на диск все грязные буферы (включая буферы clog, хранящие состояние транзакций).

Точка - момент начала записи буферов, которые были грязными на этот момент. Точка считается выполненной только после того, как все такие буферы записаны. Это гарантирует, что все изменения, сделанные до момента контрольной точки, находятся на диске.

Восстановление после сбоя начинается с момента последней завершенной КТ, что позволяет хранить только файлы журнала, записанные после нее.

Основные процессы для обслуживания буферного кеша и журнала:
- walwriter, занимающийся асинхронной записью журнала на диск. При синхронном режиме записью журнала занимается тот процесс, который выполняет фиксацию транзакции.
- процесс контрольной точки checkpointer, периодически сбрасывающий все грязные буферы на диск
- процесс фоновой записи background writer (bgwriter). Этот процесс записывает только часть грязных буферов, причем те, которые с большой вероятностью будут вытеснены в ближайшее время.
- обслуживающие процессы, читающие данные в буферный кеш. Если, несмотря на работу процессов контрольной точки и фоновой записи, вытесняемый буфер окажется грязным, обслуживающий процесс самостоятельно запишет его на диск

## Уровни журнала

Журнал можно применять для других целей, если добавить в него дополнительную информацию. Объем данных, который попадает в журнал, регулируется параметром wal_level.
- minimal - только восстановление после сбоя
- replica (по умолчанию) - добавляется информация, позволяющая использовать журнал для создания резервных копий и репликации. При репликации журнальные записи передаются на другой сервер и применяются там. Таким образом, создается и поддерживается точная копия (реплика) основного сервера
- logical - добавляется информация, позволяющая декодировать "физические" журнальные записи и сформировать их них "логические" записи о добавлении, изменении и удалении табличных строк. Это позволяет организовать логическую репликацию.

## Кластер баз данных

![[Pasted image 20250707234855.png]]

При инициализации кластера создаются 3 одинаковые базы данных.

Все остальные БД, создаваемые пользователем, клонируются из какой-либо существующей.

Шаблон template1 используется для создания новых БД. В него можно добавить объекты и расширения, которые будут копироваться в каждую новую базу данных.

Шаблон template0 не должен изменяться. Он нужен минимум в 2 ситуациях:
1. для восстановления бд из резервной копии, выполненной pg_dump (так как в эту копию попадут не только объекты данной БД, но и объекты, установленные в template1)
2. при создании новой БД с кодировкой, отличной от указанной при инициализации кластера

БД postgres иногда полагаются на нее, поэтому ее лучше не удалять.

`\l` - список всех бд
```
select datname, datistemplate,, datallowconn,, datconnlimit from pg_database;
```
- datistemplate — является ли база данных шаблоном;
- datallowconn — разрешены ли соединения с базой данных;
- datconnlimit — максимальное количество соединений (-1 = без ограничений).

```
select pg_database_size('name'); # размер бд в байтах

select pg_size_pretty(pg_database_size('name')); # человеческий формат
```

## Схемы

Схемы представляют собой пространство имен для объектов БД. Они позволяют разделить объекты на логические группы для управления ими, предотвратить конфликты имен при работе нескольких пользователей или при установке приложений

Каждый объект, существующий в БД, принадлежит какой-либо схеме.

В PostgreSQL схема и пользователь - разные сущности

![[Pasted image 20250708001104.png]]

- Кластер состоит из баз данных
	- база содержит различные схемы
		- в схемах распределены объекты

Существуют стандартные схемы, которые существуют в любой БД (pg_catalog). Можно создавать собственные схемы

`\dn` - describe namespace - показать все схемы в бд

```
create schema app;
```

Объект можно  перемещать между схемами. Перемещение происходит только в системном каталоге, сами данные физически остаются на месте.

```
alter table t set schema app;

select * from app.t;

select * from t; # error
```

## Путь поиска

При указании объекта надо определить нужную схему, поскольку в разных схемах могут храниться одноименные объекты.

Если имя объекта квалифицировано именем схемы, то используется явно указанная схема. Если имя использовано без квалификатора, PostgreSQL пытается найти имя в одной из схем, перечисленных в пути поиска, который определяется конфигурационным параметром search_path. 

Реальный путь поиска может отличаться от значения параметра search_path. Из указанного пути исключаются несуществующие схемы, а так же схемы, к которым пользователя нет доступа.

Реальный путь поиска, включая неявные схемы, возвращает вызов функции current_schemas(true). Схемы перебираются в указанном в пути поиска порядке, слева направо. Если в схеме нет объекта с нужным именем, поиск продолжается в следующей схеме.

При создании нового объекта с именем без квалификатора он попадает в первую явно указанную в пути схему.

Специальные схемы, обычно присутствуют в каждой бд:
- public - используется по умолчанию, если не выполнены иные настройки 
- pg_catalog - хранит объекты системного каталога. Системный каталог - метаинформация об объектах, принадлежащих кластеру, которая хранится в самом кластере в виде таблиц. Альтернативное представление системного каталога дает схема information_schema. Если не указать в пути поиска pg_catalog, это схема будет проверяться раньше других, чтобы системные объекты были видны

```
show search_path;
```
- временные таблицы - существуют на уровне сеанса или транзакции, не журналируются, не попадают в общий буферный кеш (используется локальный). Доступ к временным таблицам организован с помощью схем. Для сеанса создается временная схема с именем pg_temp_N, обращение идет по имени pg_temp (без номера) - для каждого сеанса это имя ссылается на конкретную временную схему. Если pg_temp нет в пути, то эта схему просматривается перед всеми остальными.