
```
sudo pacman -S postgresql
```

В результате будет установлен postgres и созданы группа и пользователь `postgres`.

для входа от имени postgres
```
sudo -iu postgres
```

инициализация кластера баз данных 
```
initdb --locale=ru_RU.UTF-8 --encoding=UTF8 -D /var/lib/postgres/data --data-checksums
```

установить автозапуск pg и запустить

создание бд

```
createdb названиеБд
```

выполнение команды от другого пользователя

```
sudo -u postgres 
```

`psql` - нативная консоль
`\c` - подключение к бд
`create database name` - создание бд
`\q` - выход из бд
`\l` - список всех бд
`\du` - вывод всех пользователей
`create user name` - создание нового юзера
`\password name` - указание пароля для пользователя 
`create user *name* with login password 'password'` - создание пользователя сразу с паролем
`drop user name` - удаление пользователя
`drop database name` - удаление бд

`psql db_name user_name` - войти бд определенным пользователем

`SELECT * FROM pg_catalog.pg_tables` - просмотр всех таблиц в текущем подключении
`\dt` - просмотр созданных схем

`VACUUM FULL ANALYZE tablename`

https://www.oslogic.ru/knowledge/598/shpargalka-po-osnovnym-komandam-postgresql/


Используется клиент-серверная архитектура.
Один экземпляр PostgreSQL одновременно работает с несколькими базами, которые вместе называется *кластером баз данных*

Для инициализации кластера:
```
initdb --locale=ru_RU.UTF-8 --encoding=UTF8 -D /var/lib/postgres/data --data-checksums
```

При инициализации создаются 3 одинаковые бд:
- **template0** -  используется, например для восстановления из логической резервной копии или для создания базы в другой кодировке и никогда не должна меняться
- **template1** - служит шаблоном для всех остальных баз данных, которые может создать пользователь в этом кластере
- **postgres** - представляет собой обычную бд, которую можно использовать

Метаинформация обо всех объектов кластера хранятся в таблицах, относящихся к [системному каталогу][https://postgrespro.ru/docs/postgresql/16/catalogs]. В каждой бд имеется собственный набор таблиц описывающий объекты это конкретной базы. Все имена таблиц системного каталога начинаются с `pg_`. 

Схемы представляют собой пространства имен для всех объектов, хранящихся в бд. Кроме пользовательских, имеются специальные служебные:
- public - используется по умолчанию для пользовательских объектов, если не выполнены иные настройки
- pg_catalog - используется для таблиц системного каталога
- information_schema - дает альтернативное представление системного каталога, регламентируемое стандартом SQL.
- pg_toast - используется для объектов, относящихся к TOAST https://habr.com/ru/companies/postgrespro/articles/710104/
- pg_temp - объединяет временные таблицы

# Табличное представление

Выделяется 2 вида представления вида данных:
- логический (человеческое представление данных)
- физический (характеристика организации данных)

Табличные пространства определяют физическое расположение данных.
У каждой бд есть табличное пространство по умолчанию, в котором создаются все объекты, без явного переопределения. Там же хранятся и объекты системного каталога.

При инициализации кластера создаются 2 табличных пространства:
- pg_default - расположен в каталоге pgdata/base и используется как табличное пространство по умолчанию, если явно не выбрать для этой цели другое пространство
- pg_global - расположен в каталоге pgdata/global и хранит общие для всего кластера объекты системного каталога.

Все пути в pg являются относительными и отсчитываются от PGDATA.

# Отношения

Самые важные объекты - таблицы и индексы - схожи в том, что состоят из строк. Последовательности (однострочные таблицы), материализованные представления (таблицы, которые помнят запрос), обычные представления (сами по себе не хранят данные) - все эти объекты называются общим словом - отношение.

# Слои и файлы

Информация связанная с отношением, организована в несколько слоев (forks) разных типов, каждый из них содержит определенный вид данных.

Первый слой представлен единственным файлом. Имя файла состоит из числового идентификатора (oid), к которому может быть добавлен суффикс, соответствующий типу слоя. 

При достижении размера файла 1 Гб создается следующий файл этого же слоя (такие файлы называются сегментами). Порядковый номер сегмента добавляется в конец имени файла.

Ограничение в 1 Гб пошло исторически для поддержки различных файловых систем. Изменение ограничения можно изменить при сборке (./configure --with-segsize)

![[Pasted image 20250409215927.png]]

Стандартные типы слоев:
- основной слой (main fork) - данные, табличные или индексные строки. основной слой существует для любых отношений (кроме представлений, которые не содержат данных). Имена файлов состоят только из числового идентификатора (равного значению столбца relfilenode таблицы pg_class)
- слой инициализации (init fork) - существует только для нежурналируемых таблиц (созданных с указанием UNLOGGED) и их индексов. Главное отличие от обычных - действия не записываются в журнал предзаписи. За счет этого работа с ними происходит быстрее, но нет возможности восстановить данные при сбое. При восстановлении идет удаление всех слоев таких объектов и записывает слой инициализации на место основного слоя - в результате получается "пустышка". При создании будет иметь такое же имя как и основной слой, но с суффиксом \_init.
- карта свободного пространства (free space map) - слой в котором, отслеживается примерный объем свободного места внутри страниц. Используется при вставке новых версий строк, чтобы быстро найти подходящую страницу, на которую поместятся добавляемые данные. Имеют суффикс \_fsm. Такие файлы создаются только при необходимости. Для ускорения поиска карта свободного пространства организована как дерево и занимает минимум 3 страницы. Существует не только для таблиц но и для индексов.
- карта видимости (visibility map) - слой, который позволяет быстро определить, требует ли страница очистки или заморозки. Для этого на каждую табличную страницу в этом слое отведено 2 бита. Одним битом отмечены страницы, которые содержат только актуальные версии строк. Процесс очистки пропускает такие страницы, поскольку в них нечего очищать. Второй бит отмечает страницы, на которых все версии строк заморожены. Такая часть слоя называется картой заморозки. Имеют суффикс \_vm. Карта видимости существует для таблиц, но не для индексов.

# Страницы

Файлы логически поделены на страницы (блоки) - это минимальный объем данных, которые считывается или записывается. Многие внутренние алгоритмы ориентированы на работу со страницами.

По умолчанию имеет размер 8 Кбайт, можно поменять в некоторых пределах (до 32 Кбайт), но только при сборке (./configure --with-blocksize). Создавать табличные пространства с разноразмерными страницами нельзя. Страницы сначала помещаются в буферный кеш (можно читать и изменять), а затем при необходимости вытесняются обратно на диск.
# TOAST

Каждая строка должна помещаться только на 1 страницу, нельзя продолжить на следующую страницу. Для длинных строк используется технология TOAST (the oversized attributes storage technique)

Варианты применения:
- длинные значения атрибутов отправляются в отдельную служебную таблицу, предварительно нарезаются на небольшие фрагменты - "тосты"
- сжать длинное значение, чтобы поместилось на страницу
- совместить 2 подхода: сжать и нарезать

Если основная таблица содержит потенциально длинные атрибуты (numeric, text - даже если они никогда не будут созданы) будет создана сразу toast-таблица

Для индексов технология TOAST предлагает только сжатие, вынесения атрибутов в отдельную таблицу не поддерживается

Стратегии хранения для различных типов столбцов:
- plain - TOAST не используется (применяется для заведомо коротких типов, таких как integer)
- extended - допускается как сжатие, так и хранение в отдельной toast-таблице
- external - длинные значения значения хранятся в toast-таблице несжатыми
- main - длинные значения в первую очередь сжимаются, в toast-таблицу попадают, только если сжатие не помогло


```
crushhh@/run/postgresql:test> SELECT 
     a.attname AS column_name,
     CASE a.attstorage
         WHEN 'p' THEN 'plain (не TOAST)'
         WHEN 'e' THEN 'extended (сжатие + TOAST)'
         WHEN 'm' THEN 'main (сжатие, затем TOAST)'
         WHEN 'x' THEN 'external (TOAST без сжатия)'
     END AS storage_strategy
 FROM 
     pg_attribute a
 JOIN 
     pg_class c ON a.attrelid = c.oid
 JOIN 
     pg_namespace n ON c.relnamespace = n.oid
 WHERE 
     c.relname = 't1'
     AND n.nspname = 'public'
     AND a.attnum > 0 
     AND NOT a.attisdropped; 
```

```
+-------------+-----------------------------+
| column_name | storage_strategy            |
|-------------+-----------------------------|
| id          | plain (не TOAST)            |
| parent_id   | plain (не TOAST)            |
| name        | external (TOAST без сжатия) |
+-------------+-----------------------------+
```

Алгоритм для вывода выглядит так:
PG стремится к тому, чтобы на странице помещалось хотя бы 4 строки. Если размер строки превышает четвертую часть страницы за вычетом заголовка (стандартный размер 2000 байт), к части значений необходимо применить TOAST. Работает до того как длина строки перестанет превышать пороговое значение (2000 байт можно переопределить параметром хранения toast_tuple_target на уровне таблицы).

1. Сначала перебираем атрибуты со стратегиями external и extended, двигаясь от самых длинных к более коротким. Extended-атрибуты сжимаются, и если после этого значение (само по себе, без учета других атрибутов) превосходит четверть страницы, оно сразу же отправляется в toast-таблицу. External-атрибуты обрабатываются так же, но не сжимаются.
2. Если после первого прохода строка все еще не помещается, по одному отправляем в toast-таблицу оставшиеся атрибуты со стратегиями external и extended.
3. Если и это не помогло, пытаемся сжать атрибуты со стратегией main, оставляя их при этом в табличной странице.
4. Если строка все равно недостаточно коротка, отправляем в toast-таблицу main-атрибуты.

Можно вручную поставить стратегию хранения на столбец, полезно если известно, что данные в столбце не сжимаются, например, JPEG-изображения. Можно установить при создании так и после:

```
ALTER TABLE t ALTER COLUMN d SET STORAGE external;
```

Для сжатия используется 2 алгоритма:
- PGLZ
- LZ4 (Лемпеля-Зива)

По умолчанию используется алгоритм указанный в default_toast_compression, значение можно установить для отдельных столбцов в предложении COMPRESSION. 

TOAST-таблицы располагаются в отдельной схеме pg_toast, не входящий в путь поиска, и поэтому обычно не виден. Для временных таблиц используется схема pg_toast_temp_N аналогично обычно pg_temp_N. 

Вместе с toast-таблицей в той же схеме создается индекс, который всегда используется для доступа к фрагментам значений.

Таким образом toast-таблица, увеличивает минимальное число файлов до 8: 3 слоя основной таблицы, 3 слоя toast-таблицы, 2 слоя toast-индекса

# Процессы и память

Экземпляр сервера PG состоит из нескольких взаимодействующих процессов.

Основные служебные процессы:
- startup - восстанавливает систему после сбоев
- autovacuum - очищает таблицы и индексы от неактуальных данных
- wal writer - записываем на диск журнальные записи
- checkpointer - выполняет контрольную точку
- writer - записывает грязные страницы на диск
- wal sender - передает журнальные записи на реплику
- wal receiver - принимает журнальные записи на реплике

Для работы всех процессов выделяется общая память. Для ускорения выполнения запросов выполняется кеширование последних прочитанных страниц.

Буферный кеш занимает большую часть общей памяти. В нем располагаются и другие буферы, которые так же  используются для ускорения работы с диском.

При сбое (отключение питания) весь кеш пропадает. Для восстановления согласованности данных ведется журнал предзаписи (WAL), при необходимости выполняющий операции повторно.

# Клиенты и клиент-серверный протокол 

