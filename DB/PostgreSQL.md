
```
sudo pacman -S postgresql
```

В результате будет установлен postgres и созданы группа и пользователь `postgres`.

для входа от имени postgres
```
sudo -iu postgres
```

инициализация кластера баз данных 
```
initdb --locale=ru_RU.UTF-8 --encoding=UTF8 -D /var/lib/postgres/data --data-checksums
```

установить автозапуск pg и запустить

создание бд

```
createdb названиеБд
```

выполнение команды от другого пользователя

```
sudo -u postgres 
```

`psql` - нативная консоль
`\c` - подключение к бд
`create database name` - создание бд
`\q` - выход из бд
`\l` - список всех бд
`\du` - вывод всех пользователей
`create user name` - создание нового юзера
`\password name` - указание пароля для пользователя 
`create user *name* with login password 'password'` - создание пользователя сразу с паролем
`drop user name` - удаление пользователя
`drop database name` - удаление бд

`psql db_name user_name` - войти бд определенным пользователем

`SELECT * FROM pg_catalog.pg_tables` - просмотр всех таблиц в текущем подключении
`\dt` - просмотр созданных схем

`VACUUM FULL ANALYZE tablename`

https://www.oslogic.ru/knowledge/598/shpargalka-po-osnovnym-komandam-postgresql/


Используется клиент-серверная архитектура.
Один экземпляр PostgreSQL одновременно работает с несколькими базами, которые вместе называется *кластером баз данных*

Для инициализации кластера:
```
initdb --locale=ru_RU.UTF-8 --encoding=UTF8 -D /var/lib/postgres/data --data-checksums
```

При инициализации создаются 3 одинаковые бд:
- **template0** -  используется, например для восстановления из логической резервной копии или для создания базы в другой кодировке и никогда не должна меняться
- **template1** - служит шаблоном для всех остальных баз данных, которые может создать пользователь в этом кластере
- **postgres** - представляет собой обычную бд, которую можно использовать

Метаинформация обо всех объектов кластера хранятся в таблицах, относящихся к [системному каталогу][https://postgrespro.ru/docs/postgresql/16/catalogs]. В каждой бд имеется собственный набор таблиц описывающий объекты это конкретной базы. Все имена таблиц системного каталога начинаются с `pg_`. 

Схемы представляют собой пространства имен для всех объектов, хранящихся в бд. Кроме пользовательских, имеются специальные служебные:
- public - используется по умолчанию для пользовательских объектов, если не выполнены иные настройки
- pg_catalog - используется для таблиц системного каталога
- information_schema - дает альтернативное представление системного каталога, регламентируемое стандартом SQL.
- pg_toast - используется для объектов, относящихся к TOAST https://habr.com/ru/companies/postgrespro/articles/710104/
- pg_temp - объединяет временные таблицы

# Табличное представление

Выделяется 2 вида представления вида данных:
- логический (человеческое представление данных)
- физический (характеристика организации данных)

Табличные пространства определяют физическое расположение данных.
У каждой бд есть табличное пространство по умолчанию, в котором создаются все объекты, без явного переопределения. Там же хранятся и объекты системного каталога.

При инициализации кластера создаются 2 табличных пространства:
- pg_default - расположен в каталоге pgdata/base и используется как табличное пространство по умолчанию, если явно не выбрать для этой цели другое пространство
- pg_global - расположен в каталоге pgdata/global и хранит общие для всего кластера объекты системного каталога.

Все пути в pg являются относительными и отсчитываются от PGDATA.

# Отношения

Самые важные объекты - таблицы и индексы - схожи в том, что состоят из строк. Последовательности (однострочные таблицы), материализованные представления (таблицы, которые помнят запрос), обычные представления (сами по себе не хранят данные) - все эти объекты называются общим словом - отношение.

# Слои и файлы

Информация связанная с отношением, организована в несколько слоев (forks) разных типов, каждый из них содержит определенный вид данных.

Первый слой представлен единственным файлом. Имя файла состоит из числового идентификатора (oid) 32-бита, к которому может быть добавлен суффикс, соответствующий типу слоя. 

При достижении размера файла 1 Гб создается следующий файл этого же слоя (такие файлы называются сегментами). Порядковый номер сегмента добавляется в конец имени файла.

Ограничение в 1 Гб пошло исторически для поддержки различных файловых систем. Изменение ограничения можно изменить при сборке (./configure --with-segsize)

![[Pasted image 20250409215927.png]]

Стандартные типы слоев:
- основной слой (main fork) - данные, табличные или индексные строки. основной слой существует для любых отношений (кроме представлений, которые не содержат данных). Имена файлов состоят только из числового идентификатора (равного значению столбца relfilenode таблицы pg_class)
- слой инициализации (init fork) - существует только для нежурналируемых таблиц (созданных с указанием UNLOGGED) и их индексов. Главное отличие от обычных - действия не записываются в журнал предзаписи. За счет этого работа с ними происходит быстрее, но нет возможности восстановить данные при сбое. При восстановлении идет удаление всех слоев таких объектов и записывает слой инициализации на место основного слоя - в результате получается "пустышка". При создании будет иметь такое же имя как и основной слой, но с суффиксом \_init.
- карта свободного пространства (free space map) - слой в котором, отслеживается примерный объем свободного места внутри страниц. Используется при вставке новых версий строк, чтобы быстро найти подходящую страницу, на которую поместятся добавляемые данные. Имеют суффикс \_fsm. Такие файлы создаются только при необходимости. Для ускорения поиска карта свободного пространства организована как дерево и занимает минимум 3 страницы. Существует не только для таблиц но и для индексов.
- карта видимости (visibility map) - слой, который позволяет быстро определить, требует ли страница очистки или заморозки. Для этого на каждую табличную страницу в этом слое отведено 2 бита. Одним битом отмечены страницы, которые содержат только актуальные версии строк. Процесс очистки пропускает такие страницы, поскольку в них нечего очищать. Второй бит отмечает страницы, на которых все версии строк заморожены. Такая часть слоя называется картой заморозки. Имеют суффикс \_vm. Карта видимости существует для таблиц, но не для индексов.

# Страницы

Файлы логически поделены на страницы (блоки) - это минимальный объем данных, которые считывается или записывается. Многие внутренние алгоритмы ориентированы на работу со страницами.

По умолчанию имеет размер 8 Кбайт, можно поменять в некоторых пределах (до 32 Кбайт), но только при сборке (./configure --with-blocksize). Создавать табличные пространства с разноразмерными страницами нельзя. Страницы сначала помещаются в буферный кеш (можно читать и изменять), а затем при необходимости вытесняются обратно на диск.
# TOAST

Каждая строка должна помещаться только на 1 страницу, нельзя продолжить на следующую страницу. Для длинных строк используется технология TOAST (the oversized attributes storage technique)

Варианты применения:
- длинные значения атрибутов отправляются в отдельную служебную таблицу, предварительно нарезаются на небольшие фрагменты - "тосты"
- сжать длинное значение, чтобы поместилось на страницу
- совместить 2 подхода: сжать и нарезать

Если основная таблица содержит потенциально длинные атрибуты (numeric, text - даже если они никогда не будут созданы) будет создана сразу toast-таблица

Для индексов технология TOAST предлагает только сжатие, вынесения атрибутов в отдельную таблицу не поддерживается

Стратегии хранения для различных типов столбцов:
- plain - TOAST не используется (применяется для заведомо коротких типов, таких как integer)
- extended - допускается как сжатие, так и хранение в отдельной toast-таблице
- external - длинные значения значения хранятся в toast-таблице несжатыми
- main - длинные значения в первую очередь сжимаются, в toast-таблицу попадают, только если сжатие не помогло


```
crushhh@/run/postgresql:test> SELECT 
     a.attname AS column_name,
     CASE a.attstorage
         WHEN 'p' THEN 'plain (не TOAST)'
         WHEN 'e' THEN 'extended (сжатие + TOAST)'
         WHEN 'm' THEN 'main (сжатие, затем TOAST)'
         WHEN 'x' THEN 'external (TOAST без сжатия)'
     END AS storage_strategy
 FROM 
     pg_attribute a
 JOIN 
     pg_class c ON a.attrelid = c.oid
 JOIN 
     pg_namespace n ON c.relnamespace = n.oid
 WHERE 
     c.relname = 't1'
     AND n.nspname = 'public'
     AND a.attnum > 0 
     AND NOT a.attisdropped; 
```

```
+-------------+-----------------------------+
| column_name | storage_strategy            |
|-------------+-----------------------------|
| id          | plain (не TOAST)            |
| parent_id   | plain (не TOAST)            |
| name        | external (TOAST без сжатия) |
+-------------+-----------------------------+
```

Алгоритм для вывода выглядит так:
PG стремится к тому, чтобы на странице помещалось хотя бы 4 строки. Если размер строки превышает четвертую часть страницы за вычетом заголовка (стандартный размер 2000 байт), к части значений необходимо применить TOAST. Работает до того как длина строки перестанет превышать пороговое значение (2000 байт можно переопределить параметром хранения toast_tuple_target на уровне таблицы).

1. Сначала перебираем атрибуты со стратегиями external и extended, двигаясь от самых длинных к более коротким. Extended-атрибуты сжимаются, и если после этого значение (само по себе, без учета других атрибутов) превосходит четверть страницы, оно сразу же отправляется в toast-таблицу. External-атрибуты обрабатываются так же, но не сжимаются.
2. Если после первого прохода строка все еще не помещается, по одному отправляем в toast-таблицу оставшиеся атрибуты со стратегиями external и extended.
3. Если и это не помогло, пытаемся сжать атрибуты со стратегией main, оставляя их при этом в табличной странице.
4. Если строка все равно недостаточно коротка, отправляем в toast-таблицу main-атрибуты.

Можно вручную поставить стратегию хранения на столбец, полезно если известно, что данные в столбце не сжимаются, например, JPEG-изображения. Можно установить при создании так и после:

```
ALTER TABLE t ALTER COLUMN d SET STORAGE external;
```

Для сжатия используется 2 алгоритма:
- PGLZ
- LZ4 (Лемпеля-Зива)

По умолчанию используется алгоритм указанный в default_toast_compression, значение можно установить для отдельных столбцов в предложении COMPRESSION. 

TOAST-таблицы располагаются в отдельной схеме pg_toast, не входящий в путь поиска, и поэтому обычно не виден. Для временных таблиц используется схема pg_toast_temp_N аналогично обычно pg_temp_N. 

Вместе с toast-таблицей в той же схеме создается индекс, который всегда используется для доступа к фрагментам значений.

Таким образом toast-таблица, увеличивает минимальное число файлов до 8: 3 слоя основной таблицы, 3 слоя toast-таблицы, 2 слоя toast-индекса

# Процессы и память

Экземпляр сервера PG состоит из нескольких взаимодействующих процессов. При старте сервера запускается процесс postgres (postmaster), он запускает все остальные процессы (fork в Unix системах)

Основные служебные процессы:
- startup - восстанавливает систему после сбоев
- autovacuum - очищает таблицы и индексы от неактуальных данных
- wal writer - записываем на диск журнальные записи
- checkpointer - выполняет контрольную точку
- writer - записывает грязные страницы на диск
- wal sender - передает журнальные записи на реплику
- wal receiver - принимает журнальные записи на реплике

Для работы всех процессов выделяется общая память. Для ускорения выполнения запросов выполняется кеширование последних прочитанных страниц.

Буферный кеш занимает большую часть общей памяти. В нем располагаются и другие буферы, которые так же  используются для ускорения работы с диском.

При сбое (отключение питания) весь кеш пропадает. Для восстановления согласованности данных ведется журнал предзаписи (WAL), при необходимости выполняющий операции повторно.

# Клиенты и клиент-серверный протокол 

Задача процесса postmaster - слушать входящие соединения. При появлении нового клиента postmaster порождает для него обслуживающий процесс (backend). Клиент устанавливает соединение и начинает сеанс общения со своим серверным процессом. Сеанс продолжается до отключения клиента или разрыва связи.

Для каждого клиента порождается собственный обслуживающий процесс. 

Проблемы большого количества соединений:
- каждому процессу требуется оперативная память для хранения кеша системного каталога, подготовленных запросов, промежуточных результатов при выполнении запросов и других данных. Для этого необходимо много доступной памяти
- при коротких сеансах тратится много ресурсов для установления соединения, порождение нового процесса и ненужное заполнение локальных кешей
- при многих процессах, требуется больше времени на просмотр их списка, а операция выполняется часто.

В таких случаях используется пул соединений, чтобы ограничить число обслуживающих процессов. Встроенного пула соединений нет в PostgreSQL, используются PgBouncer или Odyssey. Получается, что 1 процесс на сервере поочередно выполняет транзакции разных клиентов. Для взаимодействия клиента и сервера должен использоваться 1 протокол, как правило для реализации протокола используется `libpq`

Подключение всегда выполняется под определенной ролью (пользователем) к конкретной бд. 

PgBouncer - ...

# Изоляция
## Согласованность (consistency)

Важная особенность реляционных СУБД - обеспечение согласованности данных, то есть корректности данных.

Для ограничения данных можно использовать ограничения целостности (integrity constraints), такие как NOT NULL или UNIQUE. Но важно соблюдать целостность тоже важно, СУБД сама не отслеживает эти состояния (ошибка перевода денег, и 1 они потеряны, а другой ничего не получил)

Написать про транзакции!!!

Когда корректные транзакции некорректно работают вместе, это называется аномалиями одновременного выполнения.

Роль СУБД заключается в проведении параллельных транзакций и при этом гарантировать, что результат будет совпадать с результатом одного из возможных последовательных выполнений. Иными словами - изолировать транзакции друг от друга, устранив любые возможные аномалии.  

Транзакцией называется множество операций, которые переводят бд из одного корректного состояния в другое корректное состояние (согласованность) при условии, что транзакция выполнена полностью (атомарность) и без помех со стороны других транзакций (изоляция). 

## Уровни изоляции и аномалии

Аномалии:
- грязное чтение (dirty read) - транзакция читает еще не зафиксированные изменения, сделанные другой транзакцией. Допускается стандартом на уровне Read Uncommited
- потерянное обновление (lost update) - 2 транзакции читают одну и ту же строку таблицы, затем одна из них обновляет эту строку, после чего вторая обновляет эту же строку, не учитывая изменений сделанных первой транзакцией. Не допускается стандартом ни на одном уровне изоляции.
- неповторяющееся чтение (non-repeatable read) - транзакция читает одну и ту же строку 2 раза, а в промежутке между чтениями вторая транзакция изменяет (или удаляет) эту строку и фиксирует изменения. Тогда первая транзакция получит разные результаты. Допускается на уровнях Read Uncommited и Read Commited
- фантомное чтение (phantom read) - одна транзакция 2 раза читает набор строк по одинаковому условию, а в промежутке между чтениями другая транзакция добавляет строки, удовлетворяющие этому условию, и фиксирует изменения. Тогда первая транзакция получит разные наборы строк. Допускается стандартом на уровнях Read Uncommited, Read Commited, Repeatable Read.
- отсутствие допуска любых аномалий - Serializiable. 


|                  | потерянные изменения | грязное чтение | неповторяющееся чтение | фантомное чтение | другие аномалии |
| ---------------- | -------------------- | -------------- | ---------------------- | ---------------- | --------------- |
| Read Uncommitted | -                    | да             | да                     | да               | да              |
| Read Commited    | -                    | -              | да                     | да               | да              |
| Repeatable Read  | -                    | -              | -                      | да               | да              |
| Serializable     | -                    | -              | -                      | -                | -               |

## Уровни изоляции в PostgreSQL

Смена блокировочных протоколов на протокол изоляции на основе снимков (Snapshot Isolation, SI). Идея - каждая транзакция работает с согласованным снимком данных на определенный момент времени. В снимок попадают все актуальные изменения, зафиксированные до момента его создания.

Изоляция на основе снимков позволяет обходиться минимумом блокировок. Фактически блокируется только повторное изменение одной и той же строки, все остальные операции могут выполняться одновременно.

В PostgreSQL реализован многоверсионный вариант протокола SI. Многоверсионность подразумевает, что в СУБД в один момент могут сосуществовать несколько версий одной и той же строки. Это позволяет включать в снимок подходящую версию, а не обрабатывать транзакции, пытающиеся прочитать устаревшие данные.

За счет использования снимков данных изоляция в PostgreSQL грязное чтение не допускается по определению (Read Uncommited будет работать так же как Read Commited), Repeatable Read устраняет так же фантомное чтение (все еще не обеспечивает полную изоляцию)

```
BEGIN;
SHOW transaction_isolation; # просмтор текущего уровня изоляции

SHOW default_transaction_isolation; # уровень изоляции по умолчанию

BEGIN ISOLATION LEVEL REPEATEABLE READ;
```

INSERT ON CONFLICT - общие табличные выражения

Read commited
Несогласованное чтение (read skew) - одна транзакция изменяет данные, вторая их читает. Получает некорректные данные. Для избежания, оставаясь на этом же уровне, использовать в транзакции 1 оператор 

Категория изменчивости VOLATILE 

ПРИМЕРЫ !!!

Repeatable Read
Изоляция на уровне снимков оставляет возможными 2 аномалии:
- несогласованная запись (write skew)
- аномалия только читающей транзакции

Serializable
При смешивании транзакций разного уровня изоляции Serializable будет себя вести как Repeatable Read.

# Страницы и версии строк

## Структура страниц

Каждая страница имеет внутреннюю разметку и как правило содержит следующие разделы:
- заголовок - располагается в младших адресах и имеет фиксированный размер. Хранит информацию о странице, такую как контрольная сумма, а так же размеры всех остальных областей. Можно получить размеры через расширение `pageinspect`.  
```
CREATE EXTENSION pageinspect;
SELECT lower, upper, special, pagesize
FROM page_header(get_raw_page('accounts',0));
```

Структура 

![[Pasted image 20250623000001.png]]
- массив указателей на версии строк - индексные строки ссылаются на строки в таблице (6 байт идентификаторы версий строк tuple id, tid). ID состоит из номера страницы в файле основного слоя и содержит указание на версию строки в этой странице. Используется косвенная адресация (tid -> номер указателя -> текущая позиция версии строки в странице). Каждый указатель занимает 4 байта: смещение версии строки относительно начала страницы; длину версии строки; несколько битов, определяющих статус версии строк. 
- свободное пространство
- версии строк - строки (row version, tuple), данные, которые хранятся в бд, с добавлением некоторой служебной информации. Строки подразумеваются как версии строк. Мгоговерсионность предполагает существование нескольких версий одной и той же строки. На индексы многоверсионность не распространяется, индексы ссылаются на все возможные табличные версии строк
- специальную область - расположена в противоположном конце страницы, в старших адресах. Используется некоторыми типами индексов для хранения вспомогательной информации. В остальных случаях (включая табличные страницы), область имеет нулевой размер.