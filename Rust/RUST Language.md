Rust - строгий статически типизированный язык, компилируемый. Основанный на выражениях
install 
```bash 
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```

rustc --version

rustc \_\_name__.rs - скомпилировать файл

rustup upgrade

rustup doc

```rust
fn main() {
    println!("Hello world");
}
```

fn - объявление функции

() - аргументы 

{} - тело функции

println! - вызов макроса а не обычной функции (! - знак макроса)

Cargo — это система сборки и менеджер пакетов Rust.

cargo new \_\_project_name__ - создает новую директорию с проектом, инициализируя git (cargo new --vcs=git - не инициализировать git), .gitignore, Cargo.toml (toml - Tom\`s Obvious Minimal Lanuage, [package] - заголовок указывающий, что следующие операторы настраивают пакет, [dependencies] - перечисление всех зависимостей в проекте)

Пакеты кода в Rust называются crates

cargo init - автоматическая генерация Cargo.toml для существующего проекта в src

cargo build - сборка проекта (по умолчанию в режиме отладки Debug)

Cargo.lock - автоматически генерируемый файл для отслеживания точных версий зависимостей в проекте

cargo run - компиляция кода и запуск полученного исполняемого файла

cargo check - проверка что код может компилироваться, но без создания исполняемого файла

cargo build/run --release - сборка/запуск релизной версии с оптимизацией

let - объявление иммутабельной (неизменяемой) переменной. по умолчанию переменная всегда иммутабельаня
let mut - объявление мутабельной переменной

new() - ассоциированная функция (функция которая реализована на типе, в примере String)

Cargo обрабатывает семантическое версионирование

типы данных String
i32 32-ботное число
u32 беззнаковое 32-бтное число
i64 64-битное число
По умолчанию i32

trim() в строке убирает все пробелы, /n, в случае Windwos /r/n

let name: u32 - аннотация типов, метод .parse() приводит строку к этому типу, но могут ошибки при приведении типа (A👍%)

переопределение переменной через let позволяет создать переменную с таким же именем и можно изменить иммутабельное значение. можно пересоздать переменную с другим типом данных и именем, мутабельная переменная не может менять свой тип данных

```rust
fn main() {
	let x = 5;
	let x = x + 1; //Ok

	let spaces = "  ";
	let spaces = spaces.let(); // Ok

	let mut spaces = "  ";
	spaces = spaces.len(); // Err
}
```

loop {} создание бесконечного цикла

parce возвращает Result тип

Константы
различия между константами и переменными
1. константы всегда неизменяемые
2. всегда должна быть аннотация типов
3. константы можно установить только для константного выражения, а не для результата значения

2 типа данных:
- скалярный
- составной

Скалярный тип представляет одно значение. Виды:
- целые числа (arch для разных архитектур 64-бита и 32-бита, использование для индексации какой-либо коллекции)
![[Pasted image 20250216150312.png]]
- числа с плавающей точкой (по стандарту IEEE-754)
	- f64 (по умолчанию, предоставляет двойную точность)
	- f32 (одинарная точность)
- логические значения (bool)
	- true
	- false
- символы
	- char (указывается через одинарные кавычки, размер 4 байта, представляет скалярное значение Unicode от U+0000 до U+D7FF и от U+E000 до U+10FFFF)

при переполнении типа будет вызвана ошибка. в релизной версии будет перенос дополнения (256 будет 0 255 + 1). Для обработки переполнения возможно использование стандартных библиотек для примитивных числовых типов:
- Обернуть во всех режимах с помощью `wrapping_*`методов, таких как `wrapping_add`.
- Возвращает `None`значение, если при использовании методов происходит переполнение `checked_*`.
- Возвращает значение и логическое значение, указывающее, произошло ли переполнение при использовании `overflowing_*`методов.
- Насыщайте значения по минимуму или максимуму с помощью `saturating_*` методов.

Целочисленное деление усекает в сторону нуля до ближайшего целого числа

Составные типы
- кортеж - общий способ группировки нескольких значений с различными типами в один составной тип, имеют фиксированную длину, после объявления нельзя увеличить или уменьшить размер кортежа. для деструктуризации значения кортежа можно использовать сопоставление с образцом или с использованием `.index`. Можно изменять по отдельности элементы изменяемого кортежа. Кортеж без значений имеет имя `unit`, представляет собой пустое значение или пустой возвращаемый тип. Выражения неявно выражают значения unit, если они не возвращают других значений
```rust
fn main() {
	let tup: (i32, f64, u8) = (500, 6.4, 1);

	let (x,y,z) = tup;

	let t = tup.0;

	let mut t: (i32, i32) = (1,2);
	t.0 += 1;
	t.1 = 5;
}
```
- массив - каждый элемент массива должен иметь один и тот же тип, имеет фиксированную длину. идет хранение в стеке а не в куче. тип массива: \[i32; 5], создание массива из одинаковых элементов \[5; 2]. При доступе к несуществующему индексу будет вызвана ошибка
```rust
fn main() {
	let a: [i32, 5] = [1,2,3,4,5];
	let b = [5; 2]; // b = [5, 5]

	let first = a[0];
}
```
- вектор - тип коллекции из стандартной библиотеки, может увеличиваться или уменьшаться в размере

Функции

Объявление функций можно делать в любом месте программы до/после main
Параметры являются частью сигнатуры функции. В сигнатурах функции **необходимо** указывать тип для каждого параметра

Операторы (statements) - инструкции которые выполняют какое-либо действие и не возвращают значение (let)
Выражения (exoressions) - вычисляются с получением результирующего значения (вызов функции, вызов макроса, новый блок области видимости, созданный с помощью фигурных скобок). выражения не включают после себя точку с запятой, иначе он превращается в оператор и не будет возвращать значение

Определение функции является оператором, вызов функции не является оператором

```rust
fn main() {
	let y = {
		let x = 5;
		x + 1 // выражение, привязывается к y как часть оператора let. нет точки с запятой (выражения не включают точку с запятой)
	};
}
```

Функции с возвращаемыми значениями
Необходимо явно указывать тип возвращаемого значения
Можно использовать return и указать значение
Большинство функций возвращают последнее выражение неявно

```rust
fn foo() -> i32 {
	5 // возвращаемое неявно выражение
}
```

Условные выражения
```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```

Множественные условия записываются через if else if else ...
if это выражение, значит можно использовать в правой части оператора
```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}
```
Условие принимает только булево значение, автоматического преобразования к булевому значению не происходит

```rust
fn main() {
    let number = 3;

    if number { // Err
        println!("number was three");
    }
}
```

Циклы
- for - for _ in _
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
```
- while - пока условие true выполняется тело цикла
```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```
- loop - бесконечный цикл, выполняется пока не будет вызвана остановка или принудительный выход из цикла. при использовании break после него выражение будет возвращено из цикла. К циклу можно поставить метку для перемещения после break/continue 
```rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
```

функция для генерации диапазона start..end не включая последнее значение
.rev() изменить диапазон значений на обратный


# Типы управления памяти
- Сборщик мусора
- Ручное управление памятью
- Права собственности

Ownership права собственности
\- дисциплина обеспечивающая безопасность программ Rust.
Безопасность - отсутствие неопределенного поведения
Rust проверяет определена ли переменная перед использованием во время компиляции, а не во время выполнения. Код компиляции assembler хорошо оптимизирован и предотвращает большинство неопределенного поведения
Основная цель Rust - гарантировать что программа не будет иметь неопределенное поведение
Память - пространство, где данные хранятся во время выполнения программы

![[Pasted image 20250216190911.png]]

Переменные находятся либо в `stack` (так же хранятся ссылки) либо `heap` 

```rust
fn main {
	let a = 42; // хранится в стеке

	let s: String = String::from("hello") // хранится в куче
}
```

Переменная s будет являться указателем на то где хранится данные в куче. 
Что будет хранить в себе s:
- ptr - указатель на расположение в куч
- len - длина строк
- cap - емкость, сколько максимум можно добавить данных

## Преимущества стека:
- быстрый
- выделяем только нужный объем памяти
- при выходе из `scope` (области видимости) очищение памяти
- нет риска утечек памяти

## Недостатки стека:
- ограниченный размер (8 Mb в rust)
- данные должны иметь только фиксированный размер

## Преимущества кучи:
- данные могут изменять размер
- использование всей ОЗУ
- передача объектов без копирования

## Недостатки кучи:
- медленнее чем стек
- при частом выделении и освобождении блоков может произойти фрагментация кучи (состояние когда память разбита на множество мелких несмежных блоков из-за чего невозможно выделать большой непрерывный кусок памяти)

# borrowing - заимствование
временно берем какое-то значение 

```rust
fn main() {
	let s1: String = String::from("hello");

	let l = foo(&s1)
	let l2 = foo2(&mut s1)
}

fn foo(s2: &String) -> usize {
	//
	s3.len()
}

fn foo2(s3: &mut String) {
	s3.push_back(" world")
}
```

Переменные живут по фреймах. Фреймы - отображение переменных в значения в пределах одной области. Фреймы организованы в стек текущих вызываемых функций. После возврата функции Rust освобождает фрейм функции.

Box::new(\[0;100000]) - помещение данных в кучу. Данные в куче хранятся неограниченно долго. Данные в куче не привязаны к определенному стековому фрейму. 
Указатель - значение описывающее местоположение в памяти, позволяет использовать псевдонимы (aliasing)

**Принцип освобождения памяти от блока (почти верный):** если переменная привязана к блоку, то когда Rust освобождает фрейм переменной, Rust освобождает память кучи блока.

**Принцип освобождения блока (полностью верный):** если переменная владеет блоком, то когда Rust освобождает фрейм переменной, Rust освобождает и память кучи блока.

**Принцип перемещения данных кучи:** если переменная `x`передает право собственности на данные кучи другой переменной `y`, то ее `x`нельзя использовать после перемещения.

Право собственности - дисциплина управлением кучи:
- все данные кучи должна принадлежать только одной переменной
- Rust освобождает данные кучи, как только ее владелец выходит из области действия
- Право собственности может передаваться посредством перемещений, которые происходят при назначениях и вызовах функций 
- Доступ к данным кучи возможен только через ее текущего владельца, а не через предыдущего владельца

Ссылки и заимствования
ссылка - указатель, не владеющий данными, на которые он указывает. создание ссылки на переменную &name

```rust
let mut x: Box<i32> = Box::new(1);
let a: i32 = *x;         // *x reads the heap value, so a = 1
*x += 1;                 // *x on the left-side modifies the heap value,
                         //     so x points to the value 2

let r1: &Box<i32> = &x;  // r1 points to x on the stack
let b: i32 = **r1;       // two dereferences get us to the heap value

let r2: &i32 = &*x;      // r2 points to the heap value directly
let c: i32 = *r2;    // so only one dereference is needed to read it
```

Оператор разыменовывания - следование указателя на свои данные. Rust неявно вставляет оператор разыменовывания в определенных случаях, например при вызове метода с оператором точка
```rust
let x: Box<i32> = Box::new(-1);
let x_abs1 = i32::abs(*x); // explicit dereference
let x_abs2 = x.abs(); // implicit dereference
assert_eq!(x_abs1, x_abs2);
```


**Aliasing псевдонимы** - доступ к тем же данным через разные переменные
```rust
fn main() {
    let x = 42;
    let r1 = &x;
    let r2 = &x;
    
    println!("{} {}", r1, r2); // Оба псевдонима читают данные
} // immurable aliasing допустимые псевдонимы

fn main() {
    let mut x = 42;
    let r1 = &x;
    let r2 = &mut x; // Ошибка: нельзя изменять, если есть неизменяемые ссылки!
    
    println!("{}", r1); 
} // mutable aliasing запрещенный псевдоним
```

**Мутация** - изменение значения переменной

```rust
fn main() {
    let mut x = 10;
    let r = &mut x;
    *r += 5; // Разыменовываем ссылку и изменяем значение
    
    println!("{}", x); // 15
}
```


**Принцип безопасности указателя** : данные никогда не должны одновременно подвергаться псевдонимам и мутациям.


Основная идея проверки заимствований заключается в том, что переменные имеют три вида разрешений на свои данные:
- чтение - данные можно скопировать в другое место
- запись - данные могут быть изменены
- собственные (own) - данные  можно перемещать или удалять
Существуют только внутри компилятора.
Основная идея заключается в том, что ссылки могут временно удалять эти разрешения

# Важные правила:
1. Каждая переменная имеет владельца
2. У переменной может быть только 1 владелец в момент времени
3. Когда владелец удаляется из области действия, переменная тоже удаляется

# Правила ссылок:
1. В любой момент времени для определенного фрагмента данных в определенной области можно иметь только 1 изменяемую ссылку или неограниченное число неизменяемых
2. Все фрагменты данных должны быть доступны

Исправление программы: возврат ссылки на стек
```rust
fn return_a_string() -> &String {
	let s = String::from("Hello world"); 
	&s
}
```

Способы продлить жизнь строки
1. вынести владение строкой из функции `&String` -> `String`
2. вернуть строковый литерал, который существует вечно \`static (применимо если не будет изменений строки и выделение кучи не нужно)
3. отложить проверку заимствования на время выполнения используя сборку мусора (например использовать указатель с подсчетом ссылок)
4. заставить вызывающую функцию предоставить "слот" для помещения строки с использованием изменяемой строки

## Срезы строк
Срезы позволяют ссылаться на непрерывную последовательность элементов в коллекции. Срез - ссылка поэтому он является указателем а не владельцем

```rust
let s = String::from("hello world");

let hello: &str = &s[0..5];
let world: &str = &s[6..11];
let s2: &String = &s;
```
Срез указывается через диапазон в скобках
`[starting_index..ending_index]` если начинать с 0 или заканчивать завершающим числом, то их можно отбросить
Срезы - особые ссылки, поскольку являются "толстыми" указателями с метаданными. Имеют ptr и len 

![[Pasted image 20250310015351.png]]

## Vectors
Могут хранить значения только 1 типа
создание вектора 
```rust
let v: Vec<i32> = Vec::new()
```
тип `Vec<T>` позволяет создать вектор любого типа данных
макрос `vec!` создает вектор содержащий нужные значения

добавить элемент в вектор 

```rust
let mut v = Vec::new();

v.push(1);
v.push(1);
v.push(1);
```

 чтение элементов вектора
 1. \[number] - Использование `&`и `[]` дает нам ссылку на элемент по значению индекса. При выходе за границу получим Panic
 2. `get` - получаем `Option<&T>`который можно использовать с `match`. При выходе за пределы границы получим None без Panic

```rust
    let v = vec![1, 2, 3, 4, 5];

    let third: &i32 = &v[2];
    println!("The third element is {third}");

    let third: Option<&i32> = v.get(2);
    match third {
        Some(third) => println!("The third element is {third}"),
        None => println!("There is no third element."),
    }
```

итерация по значениям в векторе

```rust
// 1
    let v = vec![100, 32, 57];
    for i in &v {
        println!("{i}");
    }
// 2
    let mut v = vec![100, 32, 57];
    for i in &mut v {
        *i += 50;
    }
```

использование Enum (перечисления) для хранения нескольких типов

```rust
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
		SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
```

Как и любой другой `struct`вектор, он освобождается, когда выходит из области видимости

# Структуры
Структура - пользовательский тип данных, позволяет упаковывать вместе несколько связанных значений, которые составляют значимую группу. Нельзя отметить определенные поля как изменяемые. 
Существуют:
- структура кортежа
- структура
- структура типа unit

Объявление блока (реализации) для некоторого типа для определений функций для типа, где первый параметр всегда равен `self`, который представляет экземпляр структуры, для которой вызывается метод `impl`. Можно разделять `impl` блоки. Все функции объявленные в этом блоке называются связанными. Можно объявить связанные функции как функции без `self` (после не является методом). Часто используются для конструкторов, которые будут возвращать новый экземпляр структуры. Часто называются new, но это не ключевое слово.

Ключевые `Self`слова в возвращаемом типе и в теле функции являются псевдонимами для типа, который появляется после `impl`ключевого слова. Для вызова этой связанной функции используется синтаксис `::` с именем структуры

Геттер - метод для возвращения значения структуры в зону видимости 

```rust
struct User {

    active: bool, // поля

    username: String,

    email: String,

    sign_in_count: u64,

}

  

struct Color(i32, i32, i32); // структура кортежа, нужно чтобы дать имя всему кортежу и сделать его тип отличным от других кортежей

struct Point(i32, i32, i32);

  

struct ABC; // стуктура типа unit аналогично (), типу unit

  

#[derive(Debug)]

struct Rectangle {

    width: u32,

    height: u32,

}

  

impl Rectangle {

    fn area(&self) -> u32 {

        self.width * self.height

    }

  

    fn square(size: u32) -> Self {

        Self {

            width: size,

            height: size,

        }

    }

}

  

fn main() {

    let mut user1 = User {

        email: String::from("someone@example.com"),

        username: String::from("someusername123"),

        active: true,

        sign_in_count: 1,

    };

  

    user1.email = String::from("sdfsdf@mail.ru");

  

    let r = Rectangle {

        width: 15,

        height: 25,

    };

  
  

    let s = r.area();

  

    println!("{s}");

  

    let t = Rectangle::square(5);

    println!("{t:?}");

    // struct update

    let user2 = User {

        email: String::from("asda@mail.ru"),

        ..user1 // обязательно в в конце! использование полей из предыдущей переменной вместо: username: user1.username...

    };

}

  
  

fn build_user(email: String, username: String) -> User{

    User {

        active: true,

        username, //использование field init вместо username: username

        email,

        sign_in_count: 1

    }

}
```